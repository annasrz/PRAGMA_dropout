---
title: "QEB_dropout"
author: "Anna"
date: "2024-08-07"
output: 
  html_document:
    code_folding: hide
---

# Einflussfaktoren für eine irreguläre Beendigung einer Qualifizierten Entzugsbehandlung (QEB)


Bei QEB handelt es sich um einen stationärer Krankenhausaufenthalt mit einer Hauptdiagnose F10.2, F10.3 oder F10.4 oder einer Hauptdiagnose F10.x in Kombination mit einer sekundären Diagnose F10.2, zusätzlich zu den OPS-Codes 8-985 oder 9-647. Im Vergleich zu einer "stationären Alkoholbehandlung" (SAB) stellt QEB eine umfassendere Alkoholbehandlung dar, die zusätzlich zur medizinischen Intervention psychosoziale Therapieelemente beinhaltet. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
```

## Set Up

```{r essentials}
# clean workspace
rm(list=ls())
packages <- c("data.table", "tidyverse", "ggplot2", "glmmTMB", "comorbidity", "car", "lme4", "ordinal", "export", "mclogit", "sjPlot", "DHARMa")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Load packages
invisible(lapply(packages, library, character.only = TRUE))

# current date:
DATE <- format(Sys.Date(), "%Y%m%d")

# output folders
folder_table <- file.path("..", "output/tables")
folder_plot <- file.path("..", "output/figures")

if (!file.exists(folder_table)) {
  dir.create(folder_table, recursive = TRUE)
}

if (!file.exists(folder_plot)) {
  dir.create(folder_plot, recursive = TRUE)
}
```

## Daten Import

```{r data_import}
print(getwd())
datapath <- file.path("..", "input") 
#read in all RDS-files in datapath 
filenames <- list.files(datapath, pattern = "\\.rds$", full.names = T)

names <- c("pragma_id_GKV", "all_diagnoses", "medications", "employment", "fosterage", "income", "insurance_periods", "SAB_OPS", "SAB", "QEB_OPS", "QEB", "reha", "reha_new")

if (length(filenames) != length(names)) {
  stop("Die Anzahl der Dateien stimmt nicht mit Anzahl names überein.")
}

#save all files as separate dataframes
ldf <- lapply(filenames, readRDS)
names(ldf) <- names[1:length(ldf)]
print(names(ldf))
list2env(ldf, envir = .GlobalEnv) #save all dataframes in global environment as dataframes
```

## Daten vorbereiten

### Daten Struktur
```{r data_structure}

# convert pragmaid to factor in all dataframes
# harmonise column names

ldf <- lapply(names(ldf), function(df_name) {
  df <- ldf[[df_name]]
  
  if ("pragmaid" %in% colnames(df)) {
    df <- df %>%
      mutate(pragmaid = as.factor(pragmaid))
  }
  
  if (df_name %in% c("reha_new", "reha", "SAB", "QEB")) {
    
    date_columns <- grep("^date\\.(inpat|qwt|drvreha|reha)\\.(start|end)$", colnames(df), value = TRUE)
    
    if (length(date_columns) > 0) {
      new_names <- gsub("^date\\..*\\.", "date.treat.", date_columns)
      df <- df %>%
        rename_with(~ new_names, all_of(date_columns))
      
      treatment_types <- gsub("^date\\.(.*)\\..*$", "\\1", date_columns)  
      unique_treatments <- unique(treatment_types)
      print(treatment_types)
      df <- df %>%
        mutate(treatment = factor(unique_treatments[1])) 
    }
  }
    
      # rename SAB_id to SAB_id
      if ("inpat_id" %in% colnames(df)) {
        df <- df %>%
          rename(SAB_id = inpat_id)
      }
      
      # rename QEB_id to QEB_id
      if ("qwt_id" %in% colnames(df)) {
        df <- df %>%
          rename(QEB_id = qwt_id)
      }

  # mutate values in treatment column (SAB -> SAB, QEB -> QEB)
  if ("treatment" %in% colnames(df)) {
    df <- df %>%
      mutate(treatment = case_when(
        as.character(treatment) == "inpat" ~ "SAB",
        as.character(treatment) == "qwt" ~ "QEB",
        TRUE ~ as.character(treatment)
      )) %>%
      mutate(treatment = factor(treatment))
  }
  
  return(df)
})

# Check the structure of ldf to ensure that the names are correct
str(ldf)
names(ldf) <- names[1:length(ldf)]

list2env(ldf, envir = .GlobalEnv)

QEB <- QEB %>% 
  mutate(n.days = as.integer(difftime(as.Date(date.treat.end), as.Date(date.treat.start), units = "days")) + 1)
```

### Check der Behandlungszeiträume

## Direkte Anschlüsse identifizieren
```{r check_immconsec}

# DIRECT CONNECTIONS
# If a QEB is directly connected to the preceding QEB, both should be summarised

QEB <- QEB %>%
  arrange(pragmaid, date.treat.start) %>%
  group_by(pragmaid) %>%
  mutate(
    direkter_anschluss = (date.treat.start == lag(date.treat.end, default = NULL)) | (date.treat.start == lag(date.treat.end, default = NULL) + 1)) #the start date is the same as the end date or it is offset by one day

table(QEB$direkter_anschluss, useNA = "always")

#check
QEB %>% arrange(pragmaid, date.treat.start) %>% filter(direkter_anschluss | lead(direkter_anschluss)) %>% select(pragmaid, date.treat.start, date.treat.end)
```

Direkte Anschlüsse zu einem treatment zusammenfassen

```{r combine_consectreatments}
QEB <- QEB %>% 
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(
    date.treat.start = case_when(
      direkter_anschluss ~ lag(date.treat.start),
      TRUE ~ date.treat.start
    )
  ) %>%
  filter(is.na(lead(direkter_anschluss)) | !lead(direkter_anschluss)) %>%  # keep only those rows where `direkter_anschluss` of the next row is FALSE
  ungroup()
```

Gibt es Überlappungen in den Behandlungszeiträumen innerhalb einer Person?

```{r check_overlaps}
QEB$overlap <- FALSE

QEB <- QEB %>%
  group_by(pragmaid) %>%
  mutate(overlap = sapply(1:n(), function(i) {
    any(date.treat.start[i] < date.treat.end[-i] & date.treat.end[i] > date.treat.start[-i])
  }))

table(QEB$overlap, useNA = "always") 

overlapping_IDs <- QEB %>% filter(overlap == TRUE) %>% pull(pragmaid) %>% unique()

# Plot erstellen, um Überlappungen zu visualisieren
ggplot(QEB %>% filter(pragmaid %in% overlapping_IDs), 
       aes(y = pragmaid)) +
  geom_segment(aes(x = date.treat.start, 
                   xend = date.treat.end, 
                   yend = pragmaid, 
                   alpha = as.factor(overlap)),
               linewidth = 5) +
  scale_alpha_manual(values = c(`FALSE` = 0.2, `TRUE` = 0.6)) +
  labs(x = "Date", y = "Pragma ID") +
  theme_minimal() #some overlaps are not visible, as they are very short (1 day)
``` 

## Overlaps in Behandlungen entfernen
```{r remove_overlaps}
# keep only the longest treatment when there are overlaps
cases_to_remove <- QEB %>% 
  filter(overlap == TRUE) %>%
  group_by(pragmaid) %>%
  arrange(pragmaid, date.treat.start) %>%
  mutate(group_overlap = cumsum( #create a group for each set of overlapping treatments within a pragmaid, group_overlap = 0 means that all treatments within a pragmaid are overlapping with each other, i.e. they are all part of the same group and there are no new independent overlaps within the same pragmaid
      coalesce( #if the previous treatment is not overlapping with the current treatment, start a new group
        as.logical(date.treat.start > lag(date.treat.end, n = 1, default = first(date.treat.start)) &
                   date.treat.start > lag(date.treat.end, n = 2, default = first(date.treat.start)) &
                   date.treat.start > lag(date.treat.end, n = 3, default = first(date.treat.start)) # if all conditions are met, this means that the current treatment does not overlap with the previous three treatments -> new group index
        ), TRUE 
      ))) %>%
  group_by(pragmaid, group_overlap) %>%
  mutate(
    max_n_days = max(n.days),  # Maximalwert pro Gruppe berechnen
    keep = case_when(
      n.days == max_n_days & row_number() == which.max(n.days) ~ TRUE,  # keep the first row with max_n_days
      n.days == max_n_days ~ FALSE,                                   # set others with max_n_days to FALSE
      TRUE ~ FALSE                                                    # smaller values also set to FALSE
    )
  ) 
  
cases_to_remove %>% arrange(pragmaid, date.treat.start) %>% select(pragmaid, date.treat.start, date.treat.end, n.days, ENTL301, overlap, group_overlap, keep, max_n_days)

#common columns in cases_to_remove and QEB
common_cols <- intersect(names(cases_to_remove), names(QEB))

sum(cases_to_remove$keep == FALSE)

#QEB: remove cases with keep == FALSE 
QEB <- QEB %>% 
  left_join(cases_to_remove, by = common_cols) %>%
  filter(is.na(keep) | keep == TRUE) %>%
  select(-c(overlap, group_overlap, keep, direkter_anschluss, max_n_days))

```

## Definition "irreguläre Beendigung" mittels ENTLASS301

```{r recode_ENTL}
table(QEB$ENTL301)
str(QEB$ENTL301)

labels_entl301 <- c(
  "1" = "regulär",
  "2" = "beendet, nachstat. Beh. vorgesehen",
  "3" = "aus sonstigen Gründen beendet",
  "4" = "gegen ärztlichen Rat beendet",
  "6" = "Verlegung in ein anderes Krankenhaus",
  "7" = "Tod",
  "9" = "Rehaeinrichtung",
  "10" = "Pflegeeinrichtung",
  "13" = "externe Verlegung zur psychiatrischen Behandlung",
  "14" = "aus sonst. Gründen beend., nachstat. Beh. Vorges.",
  "15" = "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.",
  "17" = "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG",
  "22" = "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."
)

QEB$ENTL301 <- factor(QEB$ENTL301, levels = names(labels_entl301), labels = labels_entl301)

# Categorisation of ENTLASS reasons into ‘irregular termination’ (1 = yes; 2 = no) (1 = ja; 2 = nein)
QEB <- QEB %>% 
  filter(ENTL301 != "Tod") %>%
  mutate(unpl_drop = factor(case_when(
  ENTL301 %in% c("aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.") ~ 1,
  ENTL301 %in% c("regulär", "beendet, nachstat. Beh. vorgesehen", "Verlegung in ein anderes Krankenhaus", "Rehaeinrichtung", "Pflegeeinrichtung",
                 "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh.") ~ 0,
  TRUE ~ NA_real_), levels = c(0, 1), labels = c("nein", "ja")))

table(QEB$ENTL301, useNA = "always")
table(QEB$unpl_drop, useNA = "always")


#Fallzahl
QEB %>% summarise(n = n(), npragmaid = n_distinct(pragmaid))
```

## Validierung der ENTLASS301 Variable an Behandlungsdauer

```{r check_ENTL301}
prop.table(table(QEB$ENTL301))
ggplot(QEB, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

```

```{r ENTL301_ndays_dist}
desired_order_ENTL301 <- c("aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.", "beendet, nachstat. Beh. vorgesehen", "Verlegung in ein anderes Krankenhaus", "Rehaeinrichtung", "Pflegeeinrichtung", "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh.", "regulär") 

QEB <- QEB %>% mutate(ENTL301 = factor(ENTL301, levels = desired_order_ENTL301))

label_mapping <- c(
  "aus sonstigen Gründen beendet" = "aus sonstigen Gründen beendet",
  "gegen ärztlichen Rat beendet" = "gegen ärztlichen Rat beendet",
  "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh." = "gegen ärztlichen Rat beendet,\nnachstat. Beh. vorgeseh.",
  "beendet, nachstat. Beh. vorgesehen" = "beendet,\nnachstat. Beh. vorgesehen",
  "Verlegung in ein anderes Krankenhaus" = "Verlegung in anderes Krankenhaus",
  "Rehaeinrichtung" = "Rehaeinrichtung",
  "Pflegeeinrichtung" = "Pflegeeinrichtung",     
  "externe Verlegung zur psychiatrischen Behandlung" = "externe Verlegung\nzur psychiatrischen Behandlung",
  "aus sonst. Gründen beend., nachstat. Beh. Vorges." = "aus sonst. Gründen beend.,\nnachstat. Beh. Vorges.",
  "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG" = "interne Verlegung m. Wechsel\nzw. D. Gelt.b. BPflV u. KHEntgG",
  "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh." = "Fallabschl. (int. V.) b. Wechsel\nzw. Voll- und teilst. Beh.",
  "regulär" = "regulär")


ENTL_ndays <- ggplot(QEB %>% filter (ENTL301 != "Tod"), aes(x = n.days, y = ENTL301, fill = unpl_drop)) + 
  geom_jitter(alpha=0.1, size = rel(0.8)) +
  geom_boxplot(width = 0.3, outlier.shape = NA) +
  scale_x_continuous(breaks = seq(0, 100, by = 2)) +
  scale_y_discrete(labels = label_mapping) +
  #change y axis label
  ylab("Entlassungsgrund (ENTL301)") +
  xlab("Anzahl Tage in QEB") +
  theme_minimal() +
    theme(
    legend.position = "none",
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    plot.title = element_text(size = 16, face = "bold"), 
    plot.subtitle = element_text(size = 14, face = "italic"),  
    axis.title = element_text(size = 16),  
    axis.text = element_text(size = 14), 
    plot.caption = element_text(size = 10),
    plot.background = element_rect(colour = "black", fill=NA, linewidth = 1)
  )
  

ENTL_ndays

ggsave(file.path(folder_plot, "ENTL_ndays.tif"), ENTL_ndays, width = 12, height = 7, dpi = 700)

#calculate IQR for n.days only among regular discharges
QEB %>% 
  filter(ENTL301 == "regulär") %>%
  summarise(q25 = quantile(n.days, 0.25), q75 = quantile(n.days, 0.75), iqr = IQR(n.days), min = min(n.days), max = max(n.days))

```

Die Variable ENTL301 gibt den Entlassungsgrund an. Die meisten Behandlungen werden regulär beendet, wobei auffällig ist, dass es unter diesen viele Behandlungen gibt, die nur sehr kurz dauern. Außerdem gibt es eine zweigipfelige Verteilung der Behandlungsdauer bei den regulär beendeten Behandlungen mit einem Peak um eine Woche, obwohl laut Leitlinie eigentlich 21 Tage empfohlen werden. Dennoch ist die mittlere Behandlungsdauer regulärer Entlassungen deutlich längerer als bei den irregulären Entlassungen.

## Definition der Prädiktoren

### QEB_id (Behandlungserfahrung QEB)
```{r check_QEB_id}
# does the QEB_id increases with increasing date.treat.start?
QEB_check <- QEB %>% 
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(QEB_id_check = row_number()) %>%
  select(pragmaid, QEB_id, QEB_id_check, date.treat.start, date.treat.end) #QEB_id was unordered before. therefore, replace QEB_id with QEB_id_check

#replace QEB_id with QEB_id_check
QEB <- QEB %>% 
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(QEB_id = row_number() - 1) %>% # Start at 0 to align with the REHA_count_before_QEB and SAB_count_before_QEB variables, 
# as they represent the number of treatments *before* the current one.
  ungroup()
```

### Hinzufügen von REHA ID (wie viele REHAs hat eine Person zum Zeitpunkt des QEB bereits gemacht?)

```{r QEB count}

QEB_reha <- bind_rows(
  QEB, reha %>% select(pragmaid, date.treat.start, treatment, date.treat.end))

QEB_reha <- QEB_reha %>%
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(REHA_count_before_QEB = sapply(1:n(), function(i) {
    if (treatment[i] == "QEB") {
      sum(treatment[1:(i-1)] == "reha" & date.treat.end[1:(i-1)] <= date.treat.start[i])
    } else {
      NA
    }
  }))

#check
QEB_reha %>% select(pragmaid, date.treat.start, date.treat.end, QEB_id, treatment, REHA_count_before_QEB) %>% arrange(pragmaid, date.treat.start)

QEB_reha <- QEB_reha %>% filter(treatment == "QEB")

```

### Hinzufügen von SAB ID (wie viele SABs hat eine Person zum Zeitpunkt des QEB bereits gemacht?)

```{r SAB count}
QEB_reha_SAB <- bind_rows(QEB_reha, SAB %>% select(pragmaid, date.treat.start, treatment, date.treat.end))

QEB_reha_SAB <- QEB_reha_SAB %>%
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(SAB_count_before_QEB = sapply(1:n(), function(i) {
    if (treatment[i] == "QEB") {
      sum(treatment[1:(i-1)] == "SAB" & date.treat.end[1:(i-1)] < date.treat.start[i])
    } else {
      NA
    }
  }))

#check
QEB_reha_SAB %>% select(pragmaid, date.treat.start, QEB_id, treatment, REHA_count_before_QEB, SAB_count_before_QEB, REHA_count_before_QEB) %>% arrange(pragmaid, date.treat.start) 

QEB_reha_SAB <- QEB_reha_SAB %>% filter(treatment == "QEB")

```



### Hinzufügen der Stammdaten - SEX, AGE and nationality

```{r add_stammdaten}
#match pragma_id_GKV with QEB based on pragma_id (only columns names sex and yob)
total_stamm <- left_join(QEB_reha_SAB, pragma_id_GKV, by="pragmaid")

total_stamm <- total_stamm %>% 
  select(c(-hivid, -gkv.id, -dak.id, -aok.id, - gkv.y)) %>%
  mutate(age = as.integer(substr(date.treat.start, 1, 4)) - yob) %>%
  rename(gkv = gkv.x)
#4 patients with gkv aokdak (aokdak values are only present in the stamm data, but not in the QEB data, keep only gkv from QEB data)

total_stamm$pragmaid <- factor(total_stamm$pragmaid)

table(total_stamm$sex, useNA = "always")
table(total_stamm$gkv, useNA = "always")
```

### Hinzufügen Emplyoment Status

```{r add_employment}
nrow(distinct(total_stamm, pragmaid, QEB_id)) #3857
total_employ_all <- left_join(total_stamm, employment, by = "pragmaid")

# Filter rows so that QEB_start is within the period of employ_start and employ_end
total_employ <- total_employ_all %>%
  filter(date.treat.start >= date.emp.start & date.treat.start <= date.emp.end)

#do gkv.x and gkv.y have the same values?
sum(total_employ$gkv.x != total_employ$gkv.y) #0 -> gkv.x and gkv.y have the same values, delete gkv.y and rename gkv.x to gkv
total_employ <- total_employ %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

nrow(total_employ) - nrow(total_stamm) 
#after filtering, there are 41 rows less than before
missing_rows <- total_stamm %>%
  anti_join(total_employ, by = c("pragmaid", "date.treat.start", "date.treat.end")) # there is no employment data for 41 rows (-> gaps in the data, see below), some of these are excluded (active insured status is an inclusion criterion)

total_employ$emp.type <- as.factor(total_employ$emp.type)
total_employ$sex <- as.factor(total_employ$sex)
total_employ$nationality <- as.factor(total_employ$nationality)
total_employ$ward <- as.factor(total_employ$ward)
total_employ$source <- as.factor(total_employ$source)
```


#### Einschub: Sind fehlende Daten für Employment auf Unterbrechungen in Versichertenzeiten zurückzuführen?
```{r check_missing_employment}
#check if missing employment data is due to interruptions in insured periods
check_missing <- left_join(missing_rows, insurance_periods, by = c("pragmaid")) %>%
  select(pragmaid, date.treat.start, date.treat.end, date.ins.start, date.ins.end, gkv.x, gkv.y) 

sum(check_missing$gkv.x != check_missing$gkv.y) #0 -> gkv.x and gkv.y have the same values

#filter cases where the SAB treatment is covered by insurance
cases_with_valid_ins <- check_missing %>% filter(date.treat.start >= date.ins.start & date.treat.start <= date.ins.end)
# -> some, but not all cases with missing employment data are due to interruptions in insured periods

#add cases with valid insurance to SAB_employ
total_employ <- bind_rows(total_employ, total_stamm %>% filter(pragmaid %in% cases_with_valid_ins$pragmaid & date.treat.start %in% cases_with_valid_ins$date.treat.start & date.treat.end %in% cases_with_valid_ins$date.treat.end))

table(total_employ$emp.type, useNA = "always")

``` 

### Hinzufügen von Diagnose-Daten

```{r add_diagnoses}
sum(is.na(all_diagnoses$pragmaid)) #158

table(all_diagnoses$icd_type)

# keep only diagnoses of patients with icd_type confirmed, primary, secondary, any and that are not alcohol related
diagnoses_filtered <- all_diagnoses %>% 
  filter(pragmaid %in% total_employ$pragmaid) %>% 
  filter(icd_type %in% c("confirmed", "primary", "secondary", "any")) %>%
  filter(icd.alc == FALSE) %>% #keep only diagnoses that are not alcohol related (as all SAB cases are alcohol related)
  mutate(length_diag = as.integer(difftime(as.Date(date.diag.end), as.Date(date.diag.start), units = "days"))) 


#check
nrow(distinct(total_employ, pragmaid)) - nrow(distinct(diagnoses_filtered, pragmaid)) # 1 patient does not have any diagnoses that matches the criteria
summary(diagnoses_filtered$length_diag)


#plot histogram of length_diag
ggplot(diagnoses_filtered, aes(x = length_diag)) + geom_histogram(binwidth = 1) +
  facet_wrap(~setting, scales = "free_y") +
  scale_x_continuous(limits = c(0, 100))

#show cases with NA in length_diag
diagnoses_filtered %>% 
  filter(is.na(length_diag)) %>%
  select(pragmaid, icd, icd_type, setting, date.diag.start, date.diag.end)

#delete length_diag
diagnoses_filtered <- select(diagnoses_filtered, -length_diag)

sum(is.na(diagnoses_filtered$date.diag.start)) 
sum(is.na(diagnoses_filtered$date.diag.end)) 
sum(is.na(diagnoses_filtered$setting))

#if date.diag.end is NA, set it to date.diag.start
diagnoses_filtered <- diagnoses_filtered %>% 
  mutate(date.diag.start = dplyr::if_else(is.na(date.diag.start), date.diag.end, date.diag.start))


diagnoses_employ_alltimes <- left_join(total_employ, diagnoses_filtered, by = c("pragmaid")) 

nrow(distinct(diagnoses_employ_alltimes, pragmaid, QEB_id)) 

# keep only diagnoses in the timeframe of interest (maximum 2 quarters before treatment start)
diagnoses_employ_fil <- diagnoses_employ_alltimes %>%
  filter(
    # outpatient diagnoses (duration: 1 quarter) must not have been made more than 2 quarters before the start of QEB and must not be later than the start of QEB
     date.diag.start >= (date.treat.start - days(180)) & date.diag.start <= date.treat.start)

# GKV X and Y are the same, delete Y and rename X to gkv
sum(diagnoses_employ_fil$gkv.x != diagnoses_employ_fil$gkv.y) 

diagnoses_employ_fil <- diagnoses_employ_fil %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

#checks
nrow(distinct(diagnoses_employ_fil, pragmaid, QEB_id)) # 21 cases were excluded as they did not have a diagnosis in the timeframe of interest - they will be added in the end again

# Elixhauser Comorbidity Index

diagnoses_employ_fil$id_pragma_QEB <- paste(diagnoses_employ_fil$pragmaid, diagnoses_employ_fil$QEB_id, sep = "_")

comorb_elix <- comorbidity::comorbidity(x=diagnoses_employ_fil, id = "id_pragma_QEB",
                                code = "icd",map="elixhauser_icd10_quan",
                                assign0 = T,tidy.codes = T)


comorb_elix_sum <- comorb_elix %>%
  #new column with row sums using all columns except the first one
  mutate(elix_sum = rowSums(select(., -id_pragma_QEB))) %>%
  select(id_pragma_QEB, elix_sum)

nrow(distinct(total_employ, pragmaid, QEB_id)) - nrow(distinct(comorb_elix_sum, id_pragma_QEB))

total_employ$id_pragma_QEB <- paste(total_employ$pragmaid, total_employ$QEB_id, sep = "_")

diagnoses_employ <- left_join(total_employ, comorb_elix_sum, by = "id_pragma_QEB")

#are there missings? 
nrow(total_employ) - nrow(diagnoses_employ) #0
sum(is.na(diagnoses_employ$elix_sum)) #21 missings in n_diagnoses_woa

#set NAs to 0
diagnoses_employ <- diagnoses_employ %>% 
  mutate(elix_sum = replace_na(elix_sum, 0))

```

#### Diagnose Daten Descriptives 

```{r check_ndiagnoses}
#plot histogram of number of diagnoses
ggplot(diagnoses_employ, aes(x = elix_sum)) + geom_histogram(binwidth = 1)
summary(diagnoses_employ$elix_sum)
```


### Hinzufügen von Pflegegraden
```{r add_pflegegrad}
table(fosterage$fost.degree, useNA = "always")
# sowohl Pflegegrade (PG) als auch Pflegestufen (PS). Pflegegrade sind ab 2017 gültig, Pflegestufen bis 2016.

fost_QEB <- fosterage %>% 
  filter(pragmaid %in% diagnoses_employ$pragmaid)

#checks
sum(is.na(fost_QEB$date.fost.start)) #0
sum(is.na(fost_QEB$pragmaid)) #0
nrow(distinct(diagnoses_employ, pragmaid)) - nrow(distinct(fost_QEB, pragmaid)) # how many patients do have fosterage data?

fost_diagnoses_employ_alltimes <- left_join(diagnoses_employ, fost_QEB, by = "pragmaid") 


fost_diagnoses_employ_fil <- fost_diagnoses_employ_alltimes %>%
  filter((date.treat.start >= date.fost.start & is.na(date.fost.end)) | (date.treat.start >= date.fost.start & date.treat.start <= date.fost.end))

nrow(distinct(fost_diagnoses_employ_fil, pragmaid)) # how many patients do have fosterage data within the QEB period?

# GKV X - GKV Y
sum(fost_diagnoses_employ_fil $gkv.x != fost_diagnoses_employ_fil $gkv.y) #0 -> gkv.x and gkv.y are the same, delete gkv.y and rename gkv.x to gkv
fost_diagnoses_employ_fil  <- fost_diagnoses_employ_fil  %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x) %>%
  ungroup()


# add fost_diagnoses_employ_fil  to diagnoses_employ and set fosterage to NA if no fosterage data is available
fost_diagnoses_employ <- diagnoses_employ %>%
  ungroup() %>%
  left_join(fost_diagnoses_employ_fil  %>% select(id_pragma_QEB, fost.degree), by = "id_pragma_QEB") %>%
  mutate(fost.degree_bin = as.factor(ifelse(is.na(fost.degree), "nein", "ja")))


table(fost_diagnoses_employ$fost.degree, useNA = "always")
table(fost_diagnoses_employ$fost.degree_bin, useNA = "always")

```

### Hinzufügen von Medikation

```{r add_medication}

med_QEB <- medications %>% 
  filter(pragmaid %in% fost_diagnoses_employ$pragmaid)

#checks
sum(is.na(med_QEB$date.medi.disp)) #0
sum(is.na(med_QEB$pragmaid)) #0
nrow(distinct(fost_diagnoses_employ, pragmaid)) - nrow(distinct(med_QEB, pragmaid)) 

#add med_QEB to fost_diagnoses_employ
med_fost_diagnoses_employ_alltimes <- left_join(fost_diagnoses_employ, med_QEB, by = "pragmaid")
nrow(distinct(med_fost_diagnoses_employ_alltimes, pragmaid))

med_fost_diagnoses_employ_fil <- med_fost_diagnoses_employ_alltimes %>%
# only keep medication data that happend during the 3 months before the QEB
  filter(date.medi.disp >= (date.treat.start - days(30)) & date.medi.disp <= date.treat.start) %>%
  filter(ATC != "")

nrow(distinct(med_fost_diagnoses_employ_fil, pragmaid, QEB_id)) # 1475 treatments have medication data in the timeframe of interest

#GKV X - GKV Y
sum(med_fost_diagnoses_employ_fil$gkv.x != med_fost_diagnoses_employ_fil$gkv.y) #0 -> gkv.x and 
#gkv.y are the same, delete gkv.y and rename gkv.x to gkv
med_fost_diagnoses_employ_fil <- med_fost_diagnoses_employ_fil %>% 
  select(-c(gkv.y, REZ_ID, LANR_FAGS, date.medi.presc, PZN_ANZ, DDD1000_PK)) %>%
  rename(gkv = gkv.x) %>%
  ungroup()


#new variable with level 2 ATCs (therapeutische Untergruppe)
med_fost_diagnoses_employ_fil <- med_fost_diagnoses_employ_fil %>%
  group_by(id_pragma_QEB) %>%
  mutate(Level2_ATC = substr(ATC, 1, 3)) %>%
  ungroup()

#how many different values of Level2_ATC are there? 
unique_level2_ATCs <- unique(med_fost_diagnoses_employ_fil$Level2_ATC)
length(unique_level2_ATCs) #64

# which level2_ATC is the most frequent?
sorted_atc_counts <- med_fost_diagnoses_employ_fil %>%
  count(Level2_ATC, sort = TRUE) #Psycholeptika (N05) 

#calculate sum of distinct level 2 ATC codes per QEB-person combi
med_fost_diagnoses_employ_fil <- med_fost_diagnoses_employ_fil %>%
  group_by(id_pragma_QEB) %>%
  dplyr::summarize(ndistinctATClevel2 = n_distinct(Level2_ATC), 
            ndistinctATC = n_distinct(ATC)) %>%
  ungroup()

table(med_fost_diagnoses_employ_fil$ndistinctATClevel2)

med_fost_diagnoses_employ <- left_join(fost_diagnoses_employ, med_fost_diagnoses_employ_fil, by = "id_pragma_QEB")

#set NAs in ndistinct to 0
med_fost_diagnoses_employ <- med_fost_diagnoses_employ %>%
  mutate(ndistinctATClevel2 = ifelse(is.na(ndistinctATClevel2), 0, ndistinctATClevel2)) 

summary(med_fost_diagnoses_employ$ndistinctATClevel2)
hist(med_fost_diagnoses_employ$ndistinctATClevel2)
```

## Auswahl relevanter Variablen
```{r select_vars}
final_data <- med_fost_diagnoses_employ %>% 
  select(-c(KH_FALL_ID, date.kkh.start, date.kkh.end, date.treat.start, date.treat.end, date.emp.start, date.emp.end, id_pragma_QEB, fost.degree, source, icd.primary, icd.secondary, icd.admission, icd.other, died, date.death, ward, yob))
```

## Zentrieren der kontinuierlichen Variablen

Alle kontinuierlichen Variablen werden zentriert (d. h. der Mittelwert subtrahiert, so dass der Mittelwert = 0 ist). Die Koeffizienten werden dann als die Veränderung der log odds der outcomes bei einer Erhöhung des Prädiktors um eine Einheit interpretiert, wobei alle anderen (kontinuierlichen) Prädiktoren auf ihren Mittelwerten gehalten werden. Der Intercept stellt die log odds des outcomes dar, wenn alle (kontinuierlichen) Prädiktoren auf ihren Mittelwert gesetzt sind.

```{r center}  

variables_to_center <- c("age", "QEB_id", "elix_sum", "ndistinctATClevel2", "SAB_count_before_QEB", "REHA_count_before_QEB", "n.days")

#centering
for (var in variables_to_center) {
  final_data[[paste0(var, "_cent")]] <- scale(final_data[[var]], center = TRUE, scale = FALSE)
}
```

# Interkorrelations Matrix (nur kontinuierliche Variablen)

```{r correlation}
cor_matrix <-  cor(final_data %>% select(c("age_cent", "QEB_id_cent", "elix_sum_cent", "ndistinctATClevel2_cent", "REHA_count_before_QEB_cent", "SAB_count_before_QEB_cent", "n.days_cent")))
cor_matrix
cor_melted <- melt(cor_matrix)

# Erstelle die Heatmap
ggplot(cor_melted, aes(Var1, Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  #add correlation values as text
  geom_text(aes(label = round(value, 2)), vjust = 1) +
  theme_minimal() +
  labs(x = "", y = "", title = "Correlation Heatmap") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


# Speicherplatz freigeben
```{r save_data}
# identify all objects that can be deleted
objects <- ls()
objects <- objects[grepl("all|check|missing", objects)]
#delete all objects that match the pattern
rm(list = objects)
#free unused memory
gc()
```

## Überpfrüfung der Daten vor Modellierung

### Ausreißer, fehlende Werte und Datentypen
```{r check_data}
final_data$gkv <- as.factor(final_data$gkv)
final_data$pragmaid <- as.factor(final_data$pragmaid)
final_data$sex <- as.factor(final_data$sex)
final_data$nationality <- as.factor(final_data$nationality)

#check for missings
summary(final_data) #7 NAs in EmpType -> set to "other"
final_data$gkv <- as.factor(final_data$gkv)
final_data$emp.type[is.na(final_data$emp.type)] <- "other"

# QEB_id
boxplot(final_data$QEB_id) # some patients did a lot of QEBs

# ndays
boxplot(final_data$n.days)

#age
boxplot(final_data$age)

#elix_sum
boxplot(final_data$elix_sum)

#ndistinctATClevel2
boxplot(final_data$ndistinctATClevel2)
```

### Test der Modellannahme: Linearer Zusammenhang mit Logit des Outcomes

Der Zusammenhang zwischen Prädiktoren und der abhängiggen Variablen irreguläre Beendigung der Behandlung soll mittels logistischen Regressionsmodellen geschätzt werden. Dafür muss zunächst die Modellannahme geprüft werden, dass ein linearer Zusammenhang zwischen metrischen Prädikoren und dem Logit des Outcomes besteht. Um diese Annahme zu testen, werden die logistischen Regressionsmodelle geschätzt und zusätzliche Prädiktoren inkludiert, die die Interkation zwischen dem jeweiligen metrischen Prädiktor und deren Logarithmus darstellen (Hosmer & Lemeshow, 1989).
Relevant ist nur, ob die Interaktionstermine signifikant sind. Jede signifikante Interaktion deutet darauf hin, dass der jeweilige Haupteffekt die Annahme der Linearität im Logit verletzt. 

```{r linearity_test}
# Create the interaction terms of the metric predictors with their logarithm
final_data$logageInt <- log(final_data$age+1) * final_data$age
final_data$logQEB_idInt <- log(final_data$QEB_id+1) * final_data$QEB_id
final_data$logelix_sumInt <- log(final_data$elix_sum+1) * final_data$elix_sum
final_data$logndistinctATClevel2Int <- log(final_data$ndistinctATClevel2+1) * final_data$ndistinctATClevel2
final_data$logREHA_count_before_QEBInt <- log(final_data$REHA_count_before_QEB+1) * final_data$REHA_count_before_QEB
final_data$logSAB_count_before_QEBInt <- log(final_data$SAB_count_before_QEB+1) * final_data$SAB_count_before_QEB



outcomes <- c("unpl_drop")


predictors <- "sex + nationality + emp.type + age + fost.degree_bin + logageInt + QEB_id + logQEB_idInt + elix_sum + logelix_sumInt + ndistinctATClevel2 + logndistinctATClevel2Int + REHA_count_before_QEB + logREHA_count_before_QEBInt + SAB_count_before_QEB + logSAB_count_before_QEBInt"


models <- list()

# loop through each outcome and fit the model
for (outcome in outcomes) {
  formula <- as.formula(paste(outcome, "~", predictors))
  models[[outcome]] <- glm(formula, data = final_data, family = binomial(link = "logit"))
  cat("\n\n", outcome, "\n")
  print(summary(models[[outcome]]))
}

```

logageInt und logSAB_count_before_QEBInt sind signifikant -> Annahme der Linearität im Logit verletzt

#### Sind Log-Tranformationen geeignet?
```{r check_log_transformation}

#age
data_test_age <- final_data %>%
  mutate(bin = cut(age, breaks = 10)) %>%
  group_by(bin) %>%
  summarise(
    mean_pred = mean(age, na.rm = TRUE),
    p = mean(as.numeric(unpl_drop), na.rm = TRUE),
    logit_p = log(p + 0.001 / (1 - p + 0.001)),  # Logit transformation with Laplace correction (if p = 0 or p = 1)
    n = n()
  )

ggplot(data_test_age, aes(x = mean_pred, y = logit_p)) +
  geom_point() +
  geom_smooth(method = "loess", color = "red", se = FALSE) +
  geom_text(aes(label = n), hjust = 0, vjust = 0) +
  labs(
    title = "Überprüfung der log-linearen Beziehung: Alter",
    x = "Prädiktor age",
    y = "Logit(P(Y=1))"
  )

#SAB_count_before_QEB
data_test_SAB_count_before_QEB <- final_data %>%
  mutate(bin = cut(SAB_count_before_QEB, breaks = 10)) %>%
  group_by(bin) %>%
  summarise(
    mean_pred = mean(SAB_count_before_QEB, na.rm = TRUE),
    p = mean(as.numeric(unpl_drop), na.rm = TRUE),
    logit_p = log(p + 0.001 / (1 - p + 0.001)),  # Logit transformation with Laplace correction (if p = 0 or p = 1)
    n = n()
  )

ggplot(data_test_SAB_count_before_QEB, aes(x = mean_pred, y = logit_p)) +
  geom_point() +
  geom_smooth(method = "loess", color = "red", se = FALSE) +
  geom_text(aes(label = n), hjust = 0, vjust = 0) +
  labs(
    title = "Überprüfung der log-linearen Beziehung: SAB_count_before_QEB",
    x = "Prädiktor SAB_count_before_QEB",
    y = "Logit(P(Y=1))"
  )


```
Logarithmische Transformationen der Prädiktoren scheinen eher ungeeignet zu sein. Daher werden stattdessen Kategorien erstellt.

#### Kategorisierung von Alter und SAB_count_before_QEB
```{r categorize}
tertile_limits_i <- quantile(final_data$SAB_count_before_QEB[final_data$SAB_count_before_QEB > 0], probs = c(0.33, 0.66))

final_data <- final_data %>% mutate(
  SAB_count_before_QEB_cat = case_when(
    SAB_count_before_QEB == 0 ~ "0",
    SAB_count_before_QEB <= tertile_limits_i[1] ~ "1",
    SAB_count_before_QEB <= tertile_limits_i[2] ~ "2",
    TRUE ~ "3+") %>% factor(levels = c("0", "1", "2", "3+"))
)

# Check
table(final_data$SAB_count_before_QEB_cat, final_data$SAB_count_before_QEB, useNA = "always")
table(final_data$SAB_count_before_QEB_cat)



final_data <- final_data %>% mutate(
  agegroup = case_when(
    age <=34 ~ "18-34",
    age <=44 ~ "35-44",
    age <=54 ~ "45-54",
    age <=64 ~ "55-64",
    TRUE ~ "65+"
  ) %>% factor(levels = c("18-34", "35-44", "45-54", "55-64", "65+"))
)

table(final_data$agegroup, final_data$age, useNA = "always")
table(final_data$agegroup)
```

# check for multicollinearity
```{r multicollinearity}
vif_model_ENTL <- glm(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat, data = final_data, family = "binomial")

car::vif(vif_model_ENTL)
#"... when using adjusted generalized standard error inflation factor (GSIF = GVIF^(1/(2*Df)), we must take the square-root of our rules of thumb for what is a large value – aGSIF values above √2.5 (1.6) may be of concern, and values above √5 or √10 (2.2 or 3.2) are indicative of a more serious problem"
```
## Anpassung der Logistischen Modelle

```{r sensitivity}
# initialize a data frame to store model summaries
model_summaries <- data.frame(
  Model = character(),
  Deviance = numeric(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

add_model_summary <- function(model, model_name) {

  model_summaries <<- rbind(model_summaries, data.frame(
    Model = model_name,
    LogLik = logLik(model),
    AIC = AIC(model),
    BIC = BIC(model)
  ))
}

#unconditional model
model1 <- glmmTMB(unpl_drop ~ 1 + (1|pragmaid), family = "binomial", data = final_data)
summary(model1)
add_model_summary(model1, "Intercept")

model2 <- glmmTMB(unpl_drop ~ sex + (1|pragmaid), family = "binomial", data = final_data)
summary(model2)
add_model_summary(model2, "Model 2")

model3 <- glmmTMB(unpl_drop ~ sex + agegroup + (1|pragmaid), family = "binomial", data = final_data)
summary(model3)
add_model_summary(model3, "Model 3")

model4 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model4)
add_model_summary(model4, "Model 4")

model5 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + (1|pragmaid), family = "binomial", data = final_data)
summary(model5)
add_model_summary(model5, "Model 5")

model6 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + (1|pragmaid), family = "binomial", data = final_data)
summary(model6)
add_model_summary(model6, "Model 6")

model7 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model7)
add_model_summary(model7, "Model 7")

model8 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + (1|pragmaid), 
                      family = "binomial", data = final_data)
summary(model8)
add_model_summary(model8, "Model 8")

model9 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + (1|pragmaid), 
                       family = "binomial", data = final_data)
summary(model9)
add_model_summary(model9, "Model 9")

model10 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + (1|pragmaid), 
                       family = "binomial", data = final_data)
summary(model10)
add_model_summary(model10, "Model 10")

model11 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + (1|pragmaid), 
                       family = "binomial", data = final_data)
summary(model11)
add_model_summary(model11, "Model 11")

model12 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + (1|pragmaid), 
                       family = "binomial", data = final_data)
summary(model12)
add_model_summary(model12, "Model 12")
```


# Modelle mit Interaktion von QEB_id mit anderen Prädiktoren

```{r interaction}

model13 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + agegroup*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model13)
add_model_summary(model13, "Model 13") #signifikante Interaktion!
plot(ggeffects::ggpredict(model13, terms = c("QEB_id_cent", "agegroup")))
anova(model12, model13, test = "Chisq") #keine Modellverbesserung

model14 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + sex*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)  
summary(model14)
add_model_summary(model14, "Model 14") #keine signifikante Interaktion

model15 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + nationality*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)  
summary(model15)
add_model_summary(model15, "Model 15") #keine signifikante Interaktion

model16 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + emp.type*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)  
summary(model16)
add_model_summary(model16, "Model 16") #keine signifikante Interaktion

model17 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + elix_sum_cent*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model17)
add_model_summary(model17, "Model 17") #keine signifikante Interaktion

model18 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + fost.degree_bin*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model18)
add_model_summary(model18, "Model 18") #keine signifikante Interaktion

model19 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + ndistinctATClevel2_cent*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model19)
add_model_summary(model19, "Model 19") #keine signifikante Interaktion

model20 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + REHA_count_before_QEB_cent*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model20)
add_model_summary(model20, "Model 20") #keine signifikante Interaktion

model21 <- glmmTMB(unpl_drop ~ sex + agegroup + QEB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + REHA_count_before_QEB_cent + SAB_count_before_QEB_cat + SAB_count_before_QEB_cat*QEB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model21)
add_model_summary(model21, "Model 21") #keine signifikante Interaktion
```

#Evaluate model fit 

```{r model_fit}
choose_best_model <- function(summary_df, criterion) {
  if (!criterion %in% names(summary_df)) {
    stop("Ungültiges Kriterium. Wähle entweder 'LogLik', 'AIC' oder 'BIC'.")
  }

  if (criterion == "LogLik") {
    best_model_row <- summary_df[which.max(summary_df[[criterion]]), ]
  } else {
    best_model_row <- summary_df[which.min(summary_df[[criterion]]), ]
  }

  return(best_model_row)
}

choose_best_model(model_summaries, "BIC") 
choose_best_model(model_summaries, "AIC") 
choose_best_model(model_summaries, "LogLik") 

#plot model summaries as skree plot
model_summaries_long <- model_summaries %>%
  pivot_longer(cols = c(LogLik, AIC, BIC), names_to = "Criterion", values_to = "Value")

model_summaries_long$Model <- factor(model_summaries_long$Model, levels = c("Intercept", "Model 2", "Model 3", "Model 4", "Model 5", "Model 6", "Model 7", "Model 8", "Model 9", "Model 10", "Model 11", "Model 12", "Model 13", "Model 14", "Model 15", "Model 16", "Model 17", "Model 18", "Model 19", "Model 20", "Model 21"))

ggplot(model_summaries_long, aes(x = Model, y = Value, color = Criterion)) +
  geom_point(stat = "identity") +
  geom_line(aes(group = Criterion)) +
  facet_wrap(~Criterion, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Model Comparison",
    x = "Model",
    y = "Criterion Value"
  )

```

## Modellauswahl

```{r best_model}
best_model <- model12
```

## Model Diagnostik: ICC and R2
```{r model_iccr2}
#R2 = proportion of the explained variance (of the full model)
performance::r2_nakagawa(best_model) 

# ICC = proportion of explained variance that can be attributed to the random effects
residual_var <- pi^2 / 3
random_effects_var <- VarCorr(best_model)$cond$pragmaid[1, 1]
ICC <- random_effects_var / (random_effects_var + residual_var)
print(ICC)
performance::icc(best_model)
anova(model1, best_model, test = "Chisq") 


```
## Odds Ratios der signifikanten Prädiktoren
```{r odds_ratios}
# Odds Ratios
coefficents <- summary(best_model)$coefficients$cond[, 1]
se <- summary(best_model)$coefficients$cond[, 2]

odds_ratios <- exp(coefficents) #odds ratios

#95% confidence intervals
ci_lower <- exp(coefficents - 1.96 * se)
ci_upper <- exp(coefficents + 1.96 * se)

#combine into a data frame
odds_ratios_df <- data.frame(
  Predictor = names(coefficents),
  OR = odds_ratios,
  CI_lower = ci_lower,
  CI_upper = ci_upper,
  p = summary(best_model)$coefficients$cond[, 4]
)
rownames(odds_ratios_df) <- NULL
```

## Fallzahlen und Stichprobenbeschreibung

```{r sample_size}
# n patients 
n_pat <- final_data %>% distinct(pragmaid) %>% nrow()
# n treatments
n_treats <- final_data %>% nrow()

print(n_pat)
print(n_treats)

#share dropouts
prop.table(table(final_data$unpl_drop))

#AGE
summary(final_data$age)
sd(final_data$age)

#SEX
prop.table(table(final_data$sex))

#emp.type
prop.table(table(final_data$emp.type))

#nationality
prop.table(table(final_data$nationality))

#elix_sum
summary(final_data$elix_sum)

#ndistinctATClevel2
summary(final_data$ndistinctATClevel2)

#fost.degree_bin
prop.table(table(final_data$fost.degree_bin))

#REHA_count_before_QEB
summary(final_data$REHA_count_before_QEB)

#SAB_count_before_QEB
summary(final_data$SAB_count_before_QEB)

#QEB_id
summary(final_data$QEB_id)

# number of distinct pragmaIDs with QEB_id > 0 / number of all distinct pragmaIDs = proportion of patients with more than one QEB
(final_data %>% filter(QEB_id > 0) %>% distinct(pragmaid) %>% nrow()) / n_pat 
#more than 2 QEBs
(final_data %>% filter(QEB_id > 1) %>% distinct(pragmaid) %>% nrow()) / n_pat
#more than 3 QEBs
(final_data %>% filter(QEB_id > 2) %>% distinct(pragmaid) %>% nrow()) / n_pat
#more than 4 QEBs
(final_data %>% filter(QEB_id > 4) %>% distinct(pragmaid) %>% nrow()) / n_pat

#average number of treatments per patient
#QEB
n_treats_QEB <- final_data %>% group_by(pragmaid) %>% summarise(n_treats = n()) %>% pull(n_treats)
summary(n_treats_QEB)

#REHA
n_treats_reha <- final_data %>%
  group_by(pragmaid) %>%
  slice_max(REHA_count_before_QEB, with_ties = FALSE) %>% 
  ungroup() %>%
  pull(REHA_count_before_QEB)
summary(n_treats_reha)

#SAB
n_treats_SAB <- final_data %>%
  group_by(pragmaid) %>%
  slice_max(SAB_count_before_QEB, with_ties = FALSE) %>% 
  ungroup() %>%
  pull(SAB_count_before_QEB)
summary(n_treats_SAB)

```

## Plot 

```{r plot_results}

new_labels <- c(
  "(Intercept)" = "Intercept", 
  "agegroup35-44" = "Alter: 35-44\n(Ref.: 18-34)",
  "agegroup45-54" = "Alter: 45-54\n(Ref.: 18-34)",
  "agegroup55-64" = "Alter: 55-64\n(Ref.: 18-34)",
  "agegroup65+" = "Alter: 65+\n(Ref.: 18-34)",
  "QEB_id_cent" = "Behandlungserfahrung QEB",
  "sexmale" = "Geschlecht: männlich\n(Ref.: weiblich)",
  "nationalitynicht deutsch" = "Nationalität: deutsch\n(Ref.: nicht deutsch)",
  "emp.typeother" = "Beschäftigungsstatus: andere\n(Ref.: erwerbstätig)",
  "emp.typeunemployed" = "Beschäftigungsstatus: arbeitslos\n(Ref.: erwerbstätig)",
  "emp.typeretired" = "Beschäftigungsstatus: Rente\n(Ref.: erwerbstätig)",
  "elix_sum_cent" = "Elixhauser-Score",
  "fost.degree_binnein" = "Pflegestatus: nicht vorhanden\n(Ref.: vorhanden)",
  "ndistinctATClevel2_cent" = "Anzahl Medikationen",
  "SAB_count_before_QEB_cat1" = "Behandlungserfahrung SAB: 1\n(Ref.: 0)",
  "SAB_count_before_QEB_cat2" = "Behandlungserfahrung SAB: 2\n(Ref.: 0)",
  "SAB_count_before_QEB_cat3+" = "Behandlungserfahrung SAB: 3+\n(Ref.: 0)",
  "REHA_count_before_QEB_cent" = "Behandlungserfahrung REHA"
)


coefffix_plot <- sjPlot::plot_model(best_model, vline.color = "black", show.values = TRUE, value.offset = .4, value.size = 3.5, dot.size = 2, sort.est = TRUE, axis.labels = new_labels, title = "", color = c("blue", "red"),  axis.lim = c(0.092, 3), wrap.labels = 100)

coefffix_plot <- coefffix_plot + 
  theme_minimal() +
  theme(axis.text.y = element_text(size = 12),
        plot.background = element_rect(colour = "black", fill=NA, linewidth = 1)
        )
  
coefffix_plot

#save as tif
ggsave(file.path(folder_plot, "coefffix_plot_QEB.tif"), coefffix_plot, width = 8, height = 7, dpi = 700)

```

## Model Checks und Diagnostiken

```{r residuals}
model_simres <- simulateResiduals(best_model)
plot(model_simres)
```
