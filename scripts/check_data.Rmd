---
title: "check_data"
author: "Anna"
date: "2024-06-18"
output: 
  html_document:
    code_folding: hide
---
# To-Dos

- VIF von Prädiktoren berechnen
- Gleiche Analyse für INPAT
- Prädiktor Polymedikation bilden
- Prädiktor Komorbidität ggf ändern?
- Prädiktor Pflegegrad aufnehmen


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
```
# Vorbereitungen

```{r essentials}
# clean workspace
rm(list=ls())
packages <- c("data.table", "tidyverse", "ggplot2", "glmmTMB", "comorbidity")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Load packages
invisible(lapply(packages, library, character.only = TRUE))

# current date:
DATE <- format(Sys.Date(), "%Y%m%d")

# themes and options
options(scipen = 999)

# output folders
folder_table <- file.path("..", "output/tables")
folder_plot <- file.path("..", "output/figures")

if (!file.exists(folder_table)) {
  dir.create(folder_table, recursive = TRUE)
}

if (!file.exists(folder_plot)) {
  dir.create(folder_plot, recursive = TRUE)
}
```

# Daten Import

```{r data_import}
print(getwd())
datapath <- file.path("..", "input") #at least monthly users in GER
#read in all files in datapath 
filenames <- list.files(datapath, pattern = "\\.rds$", full.names = T)

#save all files as separate dataframes
ldf <- lapply(filenames, readRDS)
names(ldf) <- gsub(".rds", "", basename(filenames))
print(names(ldf))
names <- c("pragma_id_GKV", "diagnoses", "medications", "employment", "income", "insurance_periods", "inpat_OPS", "inpat", "qwt_OPS", "qwt")
names(ldf) <- names
#check if all dataframes are loaded
ls()
list2env(ldf, envir = .GlobalEnv) #save all dataframes in global environment as dataframes
rm(ldf)
```

# Daten vorbereiten

## Outcome Variablen Definition? 

### ENTLASS301
```{r recode_ENTL}
table(qwt$ENTL301)
str(qwt$ENTL301)
#QWT as factor with new labels
qwt$ENTL301 <- factor(qwt$ENTL301, levels = c(1, 2, 3, 4, 6, 7, 9, 10, 13, 14, 15, 17, 22), labels = c("regulär", "beendet, nachstat. Beh. vorgesehen", "aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "Verlegung in ein anderes Krankenhaus", "Tod", "Rehaeinrichtung",
"Pflegeeinrichtung", "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."))
#was passiert nach interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG?
```

### Validierung der ENTLASS301 Variable an Behandlungsdauer

```{r check_ENTL301}
prop.table(table(qwt$ENTL301))
str(qwt$ENTL301)
ggplot(qwt, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

#add Anzahl Tage in Behandlung
qwt <- qwt %>% 
  mutate(n_days = as.integer(difftime(as.Date(date.qwt.end), as.Date(date.qwt.start), units = "days")))

```

```{r ETNL301_ndays_dist}
prop.table(table(qwt$ENTL301))
str(qwt$ENTL301)
ggplot(qwt, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

qwt <- qwt %>% 
  filter(ENTL301 != "Tod") %>%
  mutate(unpl_drop = factor(case_when(
  ENTL301 %in% c("aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.") ~ 1,
  ENTL301 %in% c("regulär", "beendet, nachstat. Beh. vorgesehen", "Verlegung in ein anderes Krankenhaus", "Rehaeinrichtung", "Pflegeeinrichtung",
                 "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh.") ~ 0,
  TRUE ~ NA_real_), levels = c(0, 1), labels = c("nein", "ja")))

prop.table(table(qwt$unpl_drop))
ggplot(qwt, aes(x = unpl_drop, y = n_days)) + geom_violin() + geom_boxplot(width = 0.1) + theme(axis.text.x = element_text(angle = 35, hjust = 1))

ENTL_ndays <- ggplot(qwt, aes(x = ENTL301, y = n_days, fill = unpl_drop)) + 
  geom_jitter(alpha=0.1, size = rel(0.8), ) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  scale_y_continuous(breaks = seq(0, 100, by = 5)) +
  #change y axis label
  ylab("Anzahl Tage in QWT") +
  xlab("Entlassungsgrund (ENTL301)") +
  #change legend title
  labs(fill = "Unplanmäßiger Behandlungsabbruch", title = "Dauer eines Qualifizierten Entzugs nach Entlassungsgrund unter GKV Versicherten", caption = "Anmerk.: Datenpunkte markieren einzelne Behandlungen") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 35, hjust = 1, size = rel(0.85))) +
  theme(legend.position = "top")
  

ENTL_ndays

ggsave(file.path(folder_plot, "ENTL_ndays.png"), ENTL_ndays, width = 10, height = 6)

```

Die Variable ENTL301 gibt den Entlassungsgrund an. Die meisten Behandlungen werden regulär beendet, wobei auffällig ist, dass es unter diesen viele Behandlungen gibt, die nur sehr kurz dauern. Außerdem gibt es eine zweigipfelige Verteilung der Behandlungsdauer bei den regulär beendeten Behandlungen mit einem Peak um eine Woche, obwohl eigentlich 21 Tage empfohlen werden. Die ENTL301-Variable scheint daher kein idealer Indikator für einen unplanmäßigen Behandlungsabbruch zu sein.

Als alternative Operationalisierung der AV Behandlungserfolg (vorher: unplanmäßger Beendigung) des Aufenthalts ziehen wir daher stattdessen die Anzahl der Tage in Behandlung an. Die Behandlungsdauer teilen wir in drei Gruppen ein: 0-6 Tage (unter Mindestaufenthalt), 7-20 Tage (Mindestaufenthalt absolviert, aber unter empfohlener Dauer) und 21+ Tage (empfohlene Dauer). 

### Behandlungsdauer als AV
```{r create vars}
qwt <- qwt %>%
  mutate(treat_dur_cat = factor(case_when(
  #more than or 20 days in treatment
  n_days >= 20 ~ 3,
  #between 7 and 19 days (inclusive)
  n_days >= 7 & n_days < 20 ~ 2,
  #between 0 and 6 days (inclusive)
  n_days >= 0 & n_days < 7 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("0-6 Tage","7-19 Tage", "20+ Tage")))

qwt <- qwt %>%
  mutate(treat_dur_bin = factor(case_when(
  #more than or 20 days in treatment
  n_days >= 20 ~ 2,
  #below 20 days (inclusive)
  n_days < 20 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2), labels = c("unter 20 Tage", "20+ Tage")))

```

### Validierung der Behandlungsdauer als AV
```{r check_treat_dur}
prop.table(table(qwt$treat_dur_cat))
ggplot(qwt, aes(x = treat_dur_cat)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

summary(qwt$n_days)
ggplot(qwt, aes(x = n_days)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(limits = c(0, 30), breaks = seq(0, 30, by = 2), labels = seq(0, 30, by = 2)) 
#  scale_x_continuous(limits = c(0, 27)) 

```


# Hinzufügen der OPS Codes
```{r OPS_codes}
#show rows that have the same KH_FALL_ID
#qwt_duplicates <- qwt %>% 
#  group_by(KH_FALL_ID, pragmaid) %>% 
#  filter(n() > 1) #es gibt einige Personen, die innerhalb eines KH Aufenthalts mehrere Rehas gemacht haben

#rename ops.date to date.qwt.start
#qwt_OPS <- qwt_OPS %>% 
#  filter(grepl("^8-985|^8985|^9-647|^9647", OPS)) %>%
#  rename(date.qwt.start = date.ops) %>%
#  mutate(date.qwt.start = as.Date(date.qwt.start))

#qwt_full <- left_join(qwt, qwt_OPS, by = c("KH_FALL_ID", "pragmaid", "gkv", "date.qwt.start"))

```

# Hinzufügen der Stammdaten 
```{r add_stammdaten}
#match pragma_id_GKV with qwt based on pragma_id (only columns names sex and yob)
total_stamm <- left_join(qwt, pragma_id_GKV, by=c("pragmaid", "gkv"))

total_stamm <- total_stamm %>% 
  select(c(-hivid, -gkv.id, -dak.id, -aok.id)) %>%
  mutate(age = as.integer(substr(date.qwt.start, 1, 4)) - yob)

total_stamm$pragmaid <- factor(total_stamm$pragmaid)
```

# Hinzufügen Emplyoment Status
```{r add_employment}
#NAs?
sum(is.na(employment$date.emp.start)) # 0
sum(is.na(employment$date.emp.end)) # 0

total_employ_all <- left_join(total_stamm, employment, by = c("pragmaid", "gkv"))
sum(is.na(total_employ_all$date.emp.start)) # 0
sum(is.na(total_employ_all$date.emp.end)) # 0
# Filtern der Zeilen, sodass qwt_start innerhalb des Zeitraums von employ_start und employ_end liegt
total_employ <- total_employ_all %>%
  filter(date.qwt.start >= date.emp.start & date.qwt.start <= date.emp.end)

nrow(total_employ) - nrow(total_stamm) 
#after the filter, there are 42 rows less than before
missing_rows <- total_stamm %>%
  anti_join(total_employ, by = c("pragmaid", "date.qwt.start", "date.qwt.end")) #für 42 Zeilen gibt es keine employment Daten (-> Lücken in den Daten)

#add 42 missing rows to result and set employment status to NA
total_employ <- rbind(total_employ, missing_rows %>% mutate(emp.type = NA_character_), fill = T)

total_employ$emp.type <- as.factor(total_employ$emp.type)
total_employ$sex <- as.factor(total_employ$sex)
total_employ$nationality <- as.factor(total_employ$nationality)
total_employ$ward <- as.factor(total_employ$ward)
total_employ$source <- as.factor(total_employ$source)

```
# Sind fehlende Daten für Employment auf Unterbrechungen in Versichertenzeiten zurückzuführen?
```{r check_missing_employment}
#check if missing employment data is due to interruptions in insured periods
check_missing <- left_join(missing_rows, insurance_periods, by = c("pragmaid")) %>%
  select(pragmaid, date.qwt.start, date.qwt.end, date.ins.start, date.ins.end, gkv.x, gkv.y) 

#QWT Zeitraum liegt tatsächlich außerhalb des Versichertenzeitraums, daher fehlen auch die Employment Daten. Wieso? 
``` 
# Hinzufügen von Diagnose-Daten

```{r add_diagnoses}
sum(is.na(diagnoses$pragmaid)) #158

diagnoses_filtered <- diagnoses %>% 
  filter(pragmaid %in% total_employ$pragmaid) #keep only rows that are also in total_employ

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(diagnoses_filtered, pragmaid))

table(diagnoses_filtered$icd_type)

diagnoses_filtered <- diagnoses_filtered %>% 
  filter(icd_type %in% c("confirmed", "primary", "secondary")) %>%
  mutate(length_diag = as.integer(difftime(as.Date(date.diag.end), as.Date(date.diag.start), units = "days"))) 

nrow(distinct(diagnoses_filtered, pragmaid))

summary(diagnoses_filtered$length_diag) #length of the diagnoses varies a lot, some are only one day long, not useful?

#delete length_diag
diagnoses_filtered <- select(diagnoses_filtered, -length_diag)

sum(is.na(diagnoses_filtered$date.diag.start)) #20
sum(is.na(diagnoses_filtered$date.diag.end)) #20


#add diagnoses to total_employ
total_diag_all <- left_join(total_employ, diagnoses_filtered, by = c("pragmaid", "gkv")) %>%
  select(-icd_type) %>% #remove duplicate column
  filter(date.diag.start <= date.qwt.start & 
    date.diag.end >= date.qwt.end - months(1)) %>%
  distinct() #remove duplicates

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(total_diag_all, pragmaid)) #11 patients do not have any diagnoses that fulfill the criteria
nrow(distinct(total_employ, pragmaid, qwt_id)) - nrow(distinct(total_diag_all, pragmaid, qwt_id)) # 57 patient - QWT combinations do not have any diagnoses that fulfill the criteria


#calculate number of diagnoses per patient and QWT number
diag_sum <- total_diag_all %>%
  filter(icd.alc == "FALSE") %>%
  distinct(pragmaid, qwt_id, icd) %>%  # removes duplicate diagnoses based on 'icd'
  group_by(pragmaid, qwt_id) %>%
  summarize(n_diagnoses_woa = n())

nrow(distinct(total_employ, pragmaid, qwt_id)) - nrow(distinct(diag_sum, pragmaid, qwt_id))
# 99 patients - QWT combinations do not have any diagnoses that fulfill the criteria

total_diag <- left_join(total_employ, diag_sum, by = c("pragmaid", "qwt_id"))

#are there missings? 
nrow(total_employ) - nrow(total_diag) #0
sum(is.na(total_diag$n_diagnoses_woa)) #99 missings in n_diagnoses_woa
#replace missings with 0
total_diag$n_diagnoses_woa[is.na(total_diag$n_diagnoses_woa)] <- 0
```
```{r check_ndiagnoses}
#plot histogram of number of diagnoses
ggplot(total_diag, aes(x = n_diagnoses_woa)) + geom_histogram(binwidth = 1)
```


```{r gkv_check}
#are there pragmaids that have different values in gkv?
total_diag %>% 
  group_by(pragmaid) %>% 
  filter(n_distinct(gkv) > 1)
# no different gkvs for the same pragmaid
```

# Aufstellen eines Modells zur Vorhersage von unpl_drop
```{r model}
#work in progress
model1 <- glmmTMB(treat_dur_bin ~ sex + age + qwt_id + nationality + emp.type + n_diagnoses_woa + (1|gkv/pragmaid), data = total_diag, family = binomial)
summary(model1)

#model2 <- glmmTMB(treat_dur_bin ~ sex + age + qwt_id + nationality + emp.type + (1|pragmaid) + (1|gkv), data = #total_diag, family = binomial)
#summary(model2)
# exakt das gleiche Ergebnis wie model1
```
# Interpretation der festen Effekte

- 0.56 (Intercept) ist geschätzt als log odds für eine Behandlungsdauer von mind. 20 Tagen bei einer Frau, die 0 Jahre alt ist und ihre 0. QWT hat -> Log Odds negativ -> Behandlungen von mind. 20 Tagen sind unwahrscheinlicher als unter 20 Tagen

Negativer Koeffizienten für Geschlecht:männlich -> Männer haben eine geringere Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen als Frauen

negativer Koeffizient für QWT_ID -> mit fortlaufender QWT_ID sinkt die Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen, d. h., ein höherer `qwt_id`-Wert erhöht die Wahrscheinlichkeit für kürzere Aufenthalte.

Negativer Koeffizienten für emp.type:unemployed -> Arbeitslosigkeit senkt Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen im Vergleich zu bestehendem Arbeitsverhältnis

Negativer Koeffizienten für n_diagnoses_wo -> es scheint so als ob Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen sinkt, wenn Anzahl der Diagnosen steigt -> **wird der potenzielle Einfluss von einer bestimmten Diagnose getrieben?**

Die Varianz des Interzepts für die zufälligen Effekte beträgt 0.33. Das bedeutet, dass es eine gewisse Streuung zwischen den Patient:innen gibt, die nicht durch die festen Effekte erklärt wird.