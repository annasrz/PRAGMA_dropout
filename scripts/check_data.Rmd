---
title: "check_data"
author: "Anna"
date: "2024-06-18"
output: 
  html_document:
    code_folding: hide
---
# To-Dos

- VIF von Prädiktoren berechnen
- Gleiche Analyse für INPAT
- Gleiche Analyse für REHA
- Komplette Analyse in ein Modell
- Prädiktor Polymedikation bilden
- Prädiktor Komorbidität ggf ändern? Elixhauser?
- Prädiktor Pflegegrad aufnehmen


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
```
# Vorbereitungen

```{r essentials}
# clean workspace
rm(list=ls())
packages <- c("data.table", "tidyverse", "ggplot2", "glmmTMB", "comorbidity")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Load packages
invisible(lapply(packages, library, character.only = TRUE))

# current date:
DATE <- format(Sys.Date(), "%Y%m%d")

# themes and options
options(scipen = 999)

# output folders
folder_table <- file.path("..", "output/tables")
folder_plot <- file.path("..", "output/figures")

if (!file.exists(folder_table)) {
  dir.create(folder_table, recursive = TRUE)
}

if (!file.exists(folder_plot)) {
  dir.create(folder_plot, recursive = TRUE)
}
```

# Daten Import

```{r data_import}
print(getwd())
datapath <- file.path("..", "input") #at least monthly users in GER
#read in all files in datapath 
filenames <- list.files(datapath, pattern = "\\.rds$", full.names = T)

#save all files as separate dataframes
ldf <- lapply(filenames, readRDS)
names(ldf) <- gsub(".rds", "", basename(filenames))
print(names(ldf))
names <- c("pragma_id_GKV", "alc_diagnoses", "all_diagnoses", "medications", "employment", "fosterage", "income", "insurance_periods", "inpat_OPS", "inpat", "qwt_OPS", "qwt", "reha")
names(ldf) <- names
#check if all dataframes are loaded
ls()
list2env(ldf, envir = .GlobalEnv) #save all dataframes in global environment as dataframes
rm(ldf)
```

# Daten vorbereiten

## Outcome Variablen Definition? 

### ENTLASS301
```{r recode_ENTL}
table(qwt$ENTL301)
str(qwt$ENTL301)
#QWT as factor with new labels
qwt$ENTL301 <- factor(qwt$ENTL301, levels = c(1, 2, 3, 4, 6, 7, 9, 10, 13, 14, 15, 17, 22), labels = c("regulär", "beendet, nachstat. Beh. vorgesehen", "aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "Verlegung in ein anderes Krankenhaus", "Tod", "Rehaeinrichtung",
"Pflegeeinrichtung", "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."))
#was passiert nach interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG?
```

### Validierung der ENTLASS301 Variable an Behandlungsdauer

```{r check_ENTL301}
prop.table(table(qwt$ENTL301))
str(qwt$ENTL301)
ggplot(qwt, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

#add Anzahl Tage in Behandlung
qwt <- qwt %>% 
  mutate(n_days = as.integer(difftime(as.Date(date.qwt.end), as.Date(date.qwt.start), units = "days")))

```

```{r ETNL301_ndays_dist}
prop.table(table(qwt$ENTL301))
str(qwt$ENTL301)
ggplot(qwt, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

qwt <- qwt %>% 
  filter(ENTL301 != "Tod") %>%
  mutate(unpl_drop = factor(case_when(
  ENTL301 %in% c("aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.") ~ 1,
  ENTL301 %in% c("regulär", "beendet, nachstat. Beh. vorgesehen", "Verlegung in ein anderes Krankenhaus", "Rehaeinrichtung", "Pflegeeinrichtung",
                 "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh.") ~ 0,
  TRUE ~ NA_real_), levels = c(0, 1), labels = c("nein", "ja")))

prop.table(table(qwt$unpl_drop))
ggplot(qwt, aes(x = unpl_drop, y = n_days)) + geom_violin() + geom_boxplot(width = 0.1) + theme(axis.text.x = element_text(angle = 35, hjust = 1))

ENTL_ndays <- ggplot(qwt, aes(x = ENTL301, y = n_days, fill = unpl_drop)) + 
  geom_jitter(alpha=0.1, size = rel(0.8), ) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  scale_y_continuous(breaks = seq(0, 100, by = 5)) +
  #change y axis label
  ylab("Anzahl Tage in QWT") +
  xlab("Entlassungsgrund (ENTL301)") +
  #change legend title
  labs(fill = "Unplanmäßiger Behandlungsabbruch", title = "Dauer eines Qualifizierten Entzugs nach Entlassungsgrund unter GKV Versicherten", caption = "Anmerk.: Datenpunkte markieren einzelne Behandlungen") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 35, hjust = 1, size = rel(0.85))) +
  theme(legend.position = "top")
  

ENTL_ndays

ggsave(file.path(folder_plot, "ENTL_ndays.png"), ENTL_ndays, width = 10, height = 6)

```

Die Variable ENTL301 gibt den Entlassungsgrund an. Die meisten Behandlungen werden regulär beendet, wobei auffällig ist, dass es unter diesen viele Behandlungen gibt, die nur sehr kurz dauern. Außerdem gibt es eine zweigipfelige Verteilung der Behandlungsdauer bei den regulär beendeten Behandlungen mit einem Peak um eine Woche, obwohl eigentlich 21 Tage empfohlen werden. Die ENTL301-Variable scheint daher kein idealer Indikator für einen unplanmäßigen Behandlungsabbruch zu sein.

Als alternative Operationalisierung der AV Behandlungserfolg (vorher: unplanmäßger Beendigung) des Aufenthalts ziehen wir daher stattdessen die Anzahl der Tage in Behandlung an. Die Behandlungsdauer teilen wir in drei Gruppen ein: 0-6 Tage (unter Mindestaufenthalt), 7-20 Tage (Mindestaufenthalt absolviert, aber unter empfohlener Dauer) und 21+ Tage (empfohlene Dauer). 

### Behandlungsdauer als AV
```{r create vars}
qwt <- qwt %>%
  mutate(treat_dur_cat = factor(case_when(
  #more than or 20 days in treatment
  n_days >= 20 ~ 3,
  #between 7 and 19 days (inclusive)
  n_days >= 7 & n_days < 20 ~ 2,
  #between 0 and 6 days (inclusive)
  n_days >= 0 & n_days < 7 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("0-6 Tage","7-19 Tage", "20+ Tage")))

qwt <- qwt %>%
  mutate(treat_dur_bin = factor(case_when(
  #more than or 20 days in treatment
  n_days >= 20 ~ 2,
  #below 20 days (inclusive)
  n_days < 20 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2), labels = c("unter 20 Tage", "20+ Tage")))

```

### Validierung der Behandlungsdauer als AV
```{r check_treat_dur}
prop.table(table(qwt$treat_dur_cat))
ggplot(qwt, aes(x = treat_dur_cat)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

summary(qwt$n_days)
ggplot(qwt, aes(x = n_days)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(limits = c(0, 30), breaks = seq(0, 30, by = 2), labels = seq(0, 30, by = 2)) 
#  scale_x_continuous(limits = c(0, 27)) 

```


# Hinzufügen der OPS Codes
```{r OPS_codes}
#show rows that have the same KH_FALL_ID
#qwt_duplicates <- qwt %>% 
#  group_by(KH_FALL_ID, pragmaid) %>% 
#  filter(n() > 1) #es gibt einige Personen, die innerhalb eines KH Aufenthalts mehrere Rehas gemacht haben

#rename ops.date to date.qwt.start
#qwt_OPS <- qwt_OPS %>% 
#  filter(grepl("^8-985|^8985|^9-647|^9647", OPS)) %>%
#  rename(date.qwt.start = date.ops) %>%
#  mutate(date.qwt.start = as.Date(date.qwt.start))

#qwt_full <- left_join(qwt, qwt_OPS, by = c("KH_FALL_ID", "pragmaid", "gkv", "date.qwt.start"))

```

# Hinzufügen der Stammdaten 
```{r add_stammdaten}
#match pragma_id_GKV with qwt based on pragma_id (only columns names sex and yob)
total_stamm <- left_join(qwt, pragma_id_GKV, by=c("pragmaid", "gkv"))

total_stamm <- total_stamm %>% 
  select(c(-hivid, -gkv.id, -dak.id, -aok.id)) %>%
  mutate(age = as.integer(substr(date.qwt.start, 1, 4)) - yob)

total_stamm$pragmaid <- factor(total_stamm$pragmaid)
```

# Hinzufügen Emplyoment Status
```{r add_employment}
#NAs?
sum(is.na(employment$date.emp.start)) # 0
sum(is.na(employment$date.emp.end)) # 0

nrow(distinct(total_stamm, pragmaid, qwt_id)) #3857
total_employ_all <- left_join(total_stamm, employment, by = c("pragmaid", "gkv"))
sum(is.na(total_employ_all$date.emp.start)) # 0
sum(is.na(total_employ_all$date.emp.end)) # 0
# Filtern der Zeilen, sodass qwt_start innerhalb des Zeitraums von employ_start und employ_end liegt
total_employ <- total_employ_all %>%
  filter(date.qwt.start >= date.emp.start & date.qwt.start <= date.emp.end)

nrow(total_employ) - nrow(total_stamm) 
#after the filter, there are 42 rows less than before
missing_rows <- total_stamm %>%
  anti_join(total_employ, by = c("pragmaid", "date.qwt.start", "date.qwt.end")) #für 42 Zeilen gibt es keine employment Daten (-> Lücken in den Daten, siehe unten), diese werden exkludiert (aktiver Versichertenstatus ist Inklusionskriterium)

total_employ$emp.type <- as.factor(total_employ$emp.type)
total_employ$sex <- as.factor(total_employ$sex)
total_employ$nationality <- as.factor(total_employ$nationality)
total_employ$ward <- as.factor(total_employ$ward)
total_employ$source <- as.factor(total_employ$source)

```
# Sind fehlende Daten für Employment auf Unterbrechungen in Versichertenzeiten zurückzuführen?
```{r check_missing_employment}
#check if missing employment data is due to interruptions in insured periods
check_missing <- left_join(missing_rows, insurance_periods, by = c("pragmaid", "gkv")) %>%
  select(pragmaid, date.qwt.start, date.qwt.end, date.ins.start, date.ins.end, gkv) 

#QWT Zeitraum liegt tatsächlich außerhalb des Versichertenzeitraums, daher fehlen auch die Employment Daten. Wieso? 
``` 
# Hinzufügen von Diagnose-Daten

```{r add_diagnoses}
sum(is.na(all_diagnoses$pragmaid)) #158

diagnoses_filtered <- all_diagnoses %>% 
  filter(pragmaid %in% total_employ$pragmaid) #keep only rows that are also in total_employ

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(diagnoses_filtered, pragmaid)) #0, all patients have diagnoses

table(diagnoses_filtered$icd_type)

diagnoses_filtered <- diagnoses_filtered %>% 
  filter(icd_type %in% c("confirmed", "primary", "secondary", "any")) %>%
  mutate(length_diag = as.integer(difftime(as.Date(date.diag.end), as.Date(date.diag.start), units = "days"))) 

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(diagnoses_filtered, pragmaid)) #0, all patients have diagnoses that fulfill the criteria

summary(diagnoses_filtered$length_diag)
#plot histogram of length_diag
ggplot(diagnoses_filtered, aes(x = length_diag)) + geom_histogram(binwidth = 1) +
  facet_wrap(~setting) +
  scale_x_continuous(limits = c(0, 100))

#show cases with NA in length_diag
diagnoses_filtered %>% 
  filter(is.na(length_diag)) %>%
  select(pragmaid, icd, icd_type, setting, date.diag.start, date.diag.end)

#delete length_diag
diagnoses_filtered <- select(diagnoses_filtered, -length_diag)

sum(is.na(diagnoses_filtered$date.diag.start)) #20
sum(is.na(diagnoses_filtered$date.diag.end)) #17
sum(is.na(diagnoses_filtered$setting)) #0
sum(is.na(total_employ$date.qwt.start)) #0
sum(is.na(total_employ$date.qwt.end)) #0

#if date.diag.end is NA, set it to date.diag.start
#diagnoses_filtered <- diagnoses_filtered %>% 
#  mutate(date.diag.end = ifelse(is.na(date.diag.end), date.diag.start, date.diag.end))
#if date.diag.start is NA, set it to date.diag.end
#diagnoses_filtered <- diagnoses_filtered %>% 
#  mutate(date.diag.start = ifelse(is.na(date.diag.start), date.diag.end, date.diag.start))

#add diagnoses to total_employ and filter for diagnoses according to time criteria and exclude alcohol diagnoses
#total_diag_all <- left_join(total_employ, diagnoses_filtered, by = c("pragmaid", "gkv")) %>%
#  filter(
#    (date.diag.start <= date.qwt.start & date.diag.end >= (date.qwt.end - months(1))) |  # Diagnosestart muss vor oder gleich QWT-Start liegen und Diagnose muss noch bis mindestens 1 Monat vor QWT-Ende laufen
#    (is.na(date.diag.end) & date.diag.start >= (date.qwt.start - months(1)) & date.diag.start <= #date.qwt.start) |  # Falls date.diag.end NA ist, darf date.diag.start nur bis zu einem Monat vor QWT-Start und maximal gleich QWT-Start liegen
#    (is.na(date.diag.start) & date.diag.end >= (date.qwt.end - months(1)) & date.diag.end <= (date.qwt.end + weeks(1)))  # Falls date.diag.start NA ist, darf date.diag.end nur bis zu einem Monat vor und eine Woche nach QWT-Ende liegen
#  ) %>%
#  filter(icd.alc == "FALSE") %>%
#  distinct(pragmaid, qwt_id, icd, .keep_all = TRUE)

#neues Zeitfenster für Diagnosen
total_diag_all <- left_join(total_employ, diagnoses_filtered, by = c("pragmaid", "gkv")) 
nrow(distinct(total_diag_all, pragmaid, qwt_id)) #3815

total_diag_all_filtered <- total_diag_all %>%
  filter(
    #Ambulante Diagnosen (Dauer: 1 Quartal) dürfen nicht später zurückliegend als 2 Quartale vor QWT-Start gestellt worden sein und maximal gleich QWT-Start liegen
     date.diag.start >= (date.qwt.start - days(180)) & date.diag.start <= date.qwt.start)
#Arbeitsdefinition, für stationäre Diagnosen (bzw. alle anderen settings) muss Eingrenzung noch angepasst werden
  

nrow(distinct(total_diag_all_filtered, pragmaid, qwt_id)) #3815

nrow(distinct(total_diag_all, pragmaid, qwt_id)) - nrow(distinct(total_diag_all_filtered, pragmaid, qwt_id)) #0

check_missing_diag <- total_diag_all %>% 
  anti_join(total_diag_all_filtered, by = c("pragmaid", "qwt_id", "icd", "date.diag.start", "date.diag.end", "setting", "icd.alc")) %>%
  select(pragmaid, qwt_id, icd, date.diag.start, date.diag.end, date.qwt.start, date.qwt.end, setting) # -> okay

#----------------------------------------------
# Testen mit einem kleinen Beispiel-Datensatz
test_df <- data.frame(
  pragmaid = 1:6,
  gkv = c("aok", "aok", "dak", "dak", "dak", "aok"),
  date.qwt.start = as.Date(c('2021-01-01', '2021-06-01', '2021-07-01', '2021-10-01', '2022-01-01', '2022-04-01')),
  setting = c("outpatient", "inpatient", "outpatient", "inpatient", "outpatient", "outpatient"),
  date.diag.start = as.Date(c('2019-07-01', '2020-11-01', '2021-03-01', '2021-09-01', '2021-11-01', '2022-01-01')),
  qwt_id = 1:6,
  icd = c("A", "B", "C", "D", "E", "F")
)

result <- test_df %>%
  mutate(test_column = case_when(
    (setting == "outpatient" & date.diag.start >= (date.qwt.start - months(6)) & date.diag.start <= date.qwt.start) |
    (setting != "outpatient" & date.diag.start >= (date.qwt.start - months(6)) & date.diag.start <= date.qwt.start) ~ 1,
    TRUE ~ 0
  ))
#----------------------------------------------

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(total_diag_all_filtered, pragmaid)) #0 patients do not have any diagnoses that fulfill the criteria -> die Berücksichtigung von NAs in Filterung ändert hier nichts
nrow(distinct(total_employ, pragmaid, qwt_id)) - nrow(distinct(total_diag_all_filtered, pragmaid, qwt_id)) # 0 patient - QWT combinations do not have any diagnoses that fulfill the criteria -> die Berücksichtigung von NAs in Filterung ändert hier nichts


total_diag_all_filtered$id_pragma_qwt <- paste(total_diag_all_filtered$pragmaid, total_diag_all_filtered$qwt_id, sep = "_")

comorb <- comorbidity::comorbidity(x=total_diag_all_filtered, id = "id_pragma_qwt",
                                code = "icd",map="elixhauser_icd10_quan",
                                assign0 = T,tidy.codes = T)

comorb <- comorb %>%
  #new column with row sums using all columns except the first one and "alcohol"
  mutate(elix_sum = rowSums(select(., -1, -alcohol))) %>%
  select(id_pragma_qwt, elix_sum)
        

nrow(distinct(total_employ, pragmaid, qwt_id)) - nrow(distinct(comorb, id_pragma_qwt))
# 0 patients - QWT combinations do not have any diagnoses that fulfill the criteria
total_employ$id_pragma_qwt <- paste(total_employ$pragmaid, total_employ$qwt_id, sep = "_")

total_diag <- left_join(total_employ, comorb, by = "id_pragma_qwt")

#are there missings? 
nrow(total_employ) - nrow(total_diag) #0
sum(is.na(total_diag$elix_sum)) #0 missings in n_diagnoses_woa
```

```{r check_ndiagnoses}
#plot histogram of number of diagnoses
ggplot(total_diag, aes(x = elix_sum)) + geom_histogram(binwidth = 1)
summary(total_diag$elix_sum)
```
# Hinzufügen von Pflegegraden
```{r add_pflegegrad}
str(fosterage)
table(fosterage$fost.degree, useNA = "always")
# sowohl Pflegegrade (PG) als auch Pflegestufen (PS). Pflegegrade sind ab 2017 gültig, Pflegestufen bis 2016. Wie Pflegestufen in Pflegegrade umrechnen?
min(qwt$date.qwt.start) #2015-12-11

unique(qwt$date.qwt.start) %>% sort() #5 QWTs wurden vor 2016 begonnen

#Quelle: https://www.gkv-spitzenverband.de/media/dokumente/service_1/Pflegebegutachtung_2017_von_Pflegestufen_zu_Pflegegraden.pdf
# ohne PEA funktioniert Umrechnung nicht eindeutig. Daher wird die Variable zu Pflegebedarf vorhanden/nicht vorhanden kodiert

#conversion_table_PSPG <- c("PS0" = "PG2",
#                      "PS1" = "PG2",
#                      "PS2" = "PG3",
#                      "PS3" = "PG4",
#                      "PSH" = "PG5")

#fosterage <- fosterage %>% 
#  mutate(fost.degree = recode(fost.degree, !!!conversion_table))

fost_filtered <- fosterage %>% 
  filter(pragmaid %in% total_diag$pragmaid)

nrow(distinct(total_diag, pragmaid)) - nrow(distinct(fost_filtered, pragmaid))
#1675 patients do not have fosterage data
#248 patients have fosterage data
total_diag_all <- left_join(total_employ, diagnoses_filtered, by = c("pragmaid", "gkv")) %>%
  filter(
    (date.diag.start <= date.qwt.start & date.diag.end >= (date.qwt.end - months(1))) |  # Diagnosestart muss vor oder gleich QWT-Start liegen und Diagnose muss noch bis mindestens 1 Monat vor QWT-Ende laufen
    (is.na(date.diag.end) & date.diag.start >= (date.qwt.start - months(1)) & date.diag.start <= date.qwt.start) |  # Falls date.diag.end NA ist, darf date.diag.start nur bis zu einem Monat vor QWT-Start und maximal gleich QWT-Start liegen
    (is.na(date.diag.start) & date.diag.end >= (date.qwt.end - months(1)) & date.diag.end <= (date.qwt.end + weeks(1)))  # Falls date.diag.start NA ist, darf date.diag.end nur bis zu einem Monat vor und eine Woche nach QWT-Ende liegen
  ) %>%
  filter(icd.alc == "FALSE") %>%
  distinct(pragmaid, qwt_id, icd, .keep_all = TRUE)

#if pragmaid from total_diag is in fosterage and the respective QWT is within the fosterage period, add fosterage to total_diag. if not, set fosterage to NA
total_fost <- left_join(total_diag, fosterage, by = c("pragmaid", "gkv")) %>%
  filter(date.qwt.start >= date.fost.start & (is.na(date.fost.end) | date.qwt.start <= date.fost.end))


total_fost$fost.degree <- as.factor(total_fost$fost.degree)
table(total_fost$fost.degree, useNA = "always")

```  


```{r gkv_check}
#are there pragmaids that have different values in gkv?
total_diag %>% 
  group_by(pragmaid) %>% 
  filter(n_distinct(gkv) > 1)
# no different gkvs for the same pragmaid
```

# Aufstellen eines Modells zur Vorhersage von unpl_drop
```{r model}
#work in progress
model1 <- glmmTMB(treat_dur_bin ~ sex + age + qwt_id + nationality + emp.type + elix_sum + (1|gkv/pragmaid), data = total_diag, family = binomial)
summary(model1)

#AIC 3783.3
#Verleich 180 Tage Look back window und 90 Tage und 364: 180 Tage hat besseres AIC (3783.3 vs. 3784.3 vs. 3784.2)

#model2 <- glmmTMB(treat_dur_bin ~ sex + age + qwt_id + nationality + emp.type + (1|pragmaid) + (1|gkv), data = #total_diag, family = binomial)
#summary(model2)
# exakt das gleiche Ergebnis wie model1
```
# Interpretation der festen Effekte

- 0.56 (Intercept) ist geschätzt als log odds für eine Behandlungsdauer von mind. 20 Tagen bei einer Frau, die 0 Jahre alt ist und ihre 0. QWT hat -> Log Odds negativ -> Behandlungen von mind. 20 Tagen sind unwahrscheinlicher als unter 20 Tagen

Negativer Koeffizienten für Geschlecht:männlich -> Männer haben eine geringere Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen als Frauen

negativer Koeffizient für QWT_ID -> mit fortlaufender QWT_ID sinkt die Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen, d. h., ein höherer `qwt_id`-Wert erhöht die Wahrscheinlichkeit für kürzere Aufenthalte.

Negativer Koeffizienten für emp.type:unemployed -> Arbeitslosigkeit senkt Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen im Vergleich zu bestehendem Arbeitsverhältnis

Negativer Koeffizienten für n_diagnoses_wo -> es scheint so als ob Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen sinkt, wenn Anzahl der Diagnosen steigt -> **wird der potenzielle Einfluss von einer bestimmten Diagnose getrieben?**

Die Varianz des Interzepts für die zufälligen Effekte beträgt 0.33. Das bedeutet, dass es eine gewisse Streuung zwischen den Patient:innen gibt, die nicht durch die festen Effekte erklärt wird.