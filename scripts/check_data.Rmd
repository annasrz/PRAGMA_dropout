---
title: "check_data"
author: "Anna"
date: "2024-06-18"
output: 
  html_document:
    code_folding: hide
---
# To-Dos

- VIF von Prädiktoren berechnen
- Gleiche Analyse für INPAT
- Gleiche Analyse für REHA
- Komplette Analyse in ein Modell
- Prädiktor Polymedikation bilden
- Prädiktor Komorbidität: optimales Zeitfenster finden (datadriven: Modellvergleich)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
```
# Vorbereitungen

```{r essentials}
# clean workspace
rm(list=ls())
packages <- c("data.table", "tidyverse", "ggplot2", "glmmTMB", "comorbidity", "car", "lme4", "ordinal", "export", "mclogit")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Load packages
invisible(lapply(packages, library, character.only = TRUE))

# current date:
DATE <- format(Sys.Date(), "%Y%m%d")

# themes and options
options(scipen = 999)

# output folders
folder_table <- file.path("..", "output/tables")
folder_plot <- file.path("..", "output/figures")

if (!file.exists(folder_table)) {
  dir.create(folder_table, recursive = TRUE)
}

if (!file.exists(folder_plot)) {
  dir.create(folder_plot, recursive = TRUE)
}
```

# Daten Import

```{r data_import}
print(getwd())
datapath <- file.path("..", "input") #at least monthly users in GER
#read in all files in datapath 
filenames <- list.files(datapath, pattern = "\\.rds$", full.names = T)

#save all files as separate dataframes
ldf <- lapply(filenames, readRDS)
names(ldf) <- gsub(".rds", "", basename(filenames))
print(names(ldf))
names <- c("pragma_id_GKV", "alc_diagnoses", "all_diagnoses", "medications", "employment", "fosterage", "income", "insurance_periods", "inpat_OPS", "inpat", "qwt_OPS", "qwt", "reha")
names(ldf) <- names
#check if all dataframes are loaded
ls()
list2env(ldf, envir = .GlobalEnv) #save all dataframes in global environment as dataframes
rm(ldf)
```

# Daten vorbereiten

## Outcome Variablen Definition? 

### ENTLASS301
```{r recode_ENTL}
table(qwt$ENTL301)
str(qwt$ENTL301)
#QWT as factor with new labels
qwt$ENTL301 <- factor(qwt$ENTL301, levels = c(1, 2, 3, 4, 6, 7, 9, 10, 13, 14, 15, 17, 22), labels = c("regulär", "beendet, nachstat. Beh. vorgesehen", "aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "Verlegung in ein anderes Krankenhaus", "Tod", "Rehaeinrichtung",
"Pflegeeinrichtung", "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."))
#was passiert nach interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG?
```

### Validierung der ENTLASS301 Variable an Behandlungsdauer

```{r check_ENTL301}
prop.table(table(qwt$ENTL301))
str(qwt$ENTL301)
ggplot(qwt, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

#add Anzahl Tage in Behandlung
qwt <- qwt %>% 
    mutate(n_days = as.integer(difftime(as.Date(date.qwt.end), as.Date(date.qwt.start), units = "days")) + 1)

```

```{r ETNL301_ndays_dist}
prop.table(table(qwt$ENTL301))
str(qwt$ENTL301)
ggplot(qwt, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

qwt <- qwt %>% 
  filter(ENTL301 != "Tod") %>%
  mutate(unpl_drop = factor(case_when(
  ENTL301 %in% c("aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.") ~ 1,
  ENTL301 %in% c("regulär", "beendet, nachstat. Beh. vorgesehen", "Verlegung in ein anderes Krankenhaus", "Rehaeinrichtung", "Pflegeeinrichtung",
                 "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh.") ~ 0,
  TRUE ~ NA_real_), levels = c(0, 1), labels = c("nein", "ja")))

prop.table(table(qwt$unpl_drop))
ggplot(qwt, aes(x = unpl_drop, y = n_days)) + geom_violin() + geom_boxplot(width = 0.1) + theme(axis.text.x = element_text(angle = 35, hjust = 1))

ENTL_ndays <- ggplot(qwt, aes(x = ENTL301, y = n_days, fill = unpl_drop)) + 
  geom_jitter(alpha=0.1, size = rel(0.8), ) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  scale_y_continuous(breaks = seq(0, 100, by = 5)) +
  #change y axis label
  ylab("Anzahl Tage in QE") +
  xlab("Entlassungsgrund (ENTL301)") +
  #change legend title
  labs(fill = "Unplanmäßiger Behandlungsabbruch", title = "Dauer eines Qualifizierten Entzugs nach Entlassungsgrund unter GKV Versicherten", caption = "Anmerk.: Datenpunkte markieren einzelne Behandlungen") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 35, hjust = 1, size = rel(0.85))) +
  theme(legend.position = "top")
  

ENTL_ndays
graph2doc(x = ENTL_ndays, file=file.path(folder_plot, "ENTL_ndays.png"), width=7, height=5)
ggsave(file.path(folder_plot, "ENTL_ndays.png"), ENTL_ndays, width = 10, height = 6)

#calculate IQR for n_days only among regulär beendeten Behandlungen
qwt %>% 
  filter(ENTL301 == "regulär") %>%
  summarise(q25 = quantile(n_days, 0.25), q75 = quantile(n_days, 0.75), iqr = IQR(n_days), min = min(n_days), max = max(n_days))

```

Die Variable ENTL301 gibt den Entlassungsgrund an. Die meisten Behandlungen werden regulär beendet, wobei auffällig ist, dass es unter diesen viele Behandlungen gibt, die nur sehr kurz dauern. Außerdem gibt es eine zweigipfelige Verteilung der Behandlungsdauer bei den regulär beendeten Behandlungen mit einem Peak um eine Woche, obwohl eigentlich 21 Tage empfohlen werden. Die ENTL301-Variable scheint daher kein idealer Indikator für einen unplanmäßigen Behandlungsabbruch zu sein.

Als alternative Operationalisierung der AV Behandlungserfolg (vorher: unplanmäßger Beendigung) des Aufenthalts ziehen wir daher stattdessen die Anzahl der Tage in Behandlung an. Die Behandlungsdauer teilen wir in drei Gruppen ein: 0-6 Tage (unter Mindestaufenthalt), 7-20 Tage (Mindestaufenthalt absolviert, aber unter empfohlener Dauer) und 21+ Tage (empfohlene Dauer). 

### Behandlungsdauer als AV
```{r create vars}
qwt <- qwt %>%
  mutate(treat_dur_cat = factor(case_when(
  #more than or 20 days in treatment
  n_days >= 21 ~ 3,
  #between 7 and 19 days (inclusive)
  n_days >= 7 & n_days < 21 ~ 2,
  #between 0 and 6 days (inclusive)
  n_days >= 0 & n_days < 7 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("1-6 Tage","7-20 Tage", "21+ Tage")))

qwt <- qwt %>%
  mutate(treat_dur_bin = factor(case_when(
  #more than or 20 days in treatment
  n_days >= 21 ~ 2,
  #below 20 days (inclusive)
  n_days < 21 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2), labels = c("unter 21 Tage", "21+ Tage")))

```

### Validierung der Behandlungsdauer als AV
```{r check_treat_dur}
prop.table(table(qwt$treat_dur_cat))
ggplot(qwt, aes(x = treat_dur_cat)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

summary(qwt$n_days)
ggplot(qwt, aes(x = n_days)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(limits = c(0, 30), breaks = seq(0, 30, by = 2), labels = seq(0, 30, by = 2)) 
#  scale_x_continuous(limits = c(0, 27)) 

```
# Validierung qwt_id
```{r check_qwt_id}
# does the qwt_id increases with increasing date.qwt.start?
qwt_check <- qwt %>% 
  group_by(pragmaid) %>%
  arrange(date.qwt.start) %>%
  mutate(qwt_id_check = row_number()) %>%
  select(pragmaid, qwt_id, qwt_id_check, date.qwt.start, date.qwt.end) #qwt_id does not increase with increasing date.qwt.start. therefore, replace qwt_id with qwt_id_check

#replace qwt_id with qwt_id_check
qwt <- qwt %>% 
  group_by(pragmaid) %>%
  arrange(date.qwt.start) %>%
  mutate(qwt_id = row_number()) %>%
  ungroup()
```

# Hinzufügen der OPS Codes
```{r OPS_codes}
#show rows that have the same KH_FALL_ID
#qwt_duplicates <- qwt %>% 
#  group_by(KH_FALL_ID, pragmaid) %>% 
#  filter(n() > 1) #es gibt einige Personen, die innerhalb eines KH Aufenthalts mehrere Rehas gemacht haben

#rename ops.date to date.qwt.start
#qwt_OPS <- qwt_OPS %>% 
#  filter(grepl("^8-985|^8985|^9-647|^9647", OPS)) %>%
#  rename(date.qwt.start = date.ops) %>%
#  mutate(date.qwt.start = as.Date(date.qwt.start))

#qwt_full <- left_join(qwt, qwt_OPS, by = c("KH_FALL_ID", "pragmaid", "gkv", "date.qwt.start"))

```

# Hinzufügen der Stammdaten 
```{r add_stammdaten}
#match pragma_id_GKV with qwt based on pragma_id (only columns names sex and yob)
total_stamm <- left_join(qwt, pragma_id_GKV, by="pragmaid")

total_stamm <- total_stamm %>% 
  select(c(-hivid, -gkv.id, -dak.id, -aok.id, - gkv.y)) %>%
  mutate(age = as.integer(substr(date.qwt.start, 1, 4)) - yob) %>%
  rename(gkv = gkv.x)
#4 patients with gkv aokdak (aokdak values are only present in the stamm data, but not in the qwt data, keep only gkv from qwt data)

total_stamm$pragmaid <- factor(total_stamm$pragmaid)

table(total_stamm$sex, useNA = "always")
table(total_stamm$gkv, useNA = "always")
```

# Hinzufügen Emplyoment Status
```{r add_employment}
#NAs?
sum(is.na(employment$date.emp.start)) # 0
sum(is.na(employment$date.emp.end)) # 0

nrow(distinct(total_stamm, pragmaid, qwt_id)) #3857
total_employ_all <- left_join(total_stamm, employment, by = "pragmaid")
sum(is.na(total_employ_all$date.emp.start)) # 0
sum(is.na(total_employ_all$date.emp.end)) # 0
# Filtern der Zeilen, sodass qwt_start innerhalb des Zeitraums von employ_start und employ_end liegt
total_employ <- total_employ_all %>%
  filter(date.qwt.start >= date.emp.start & date.qwt.start <= date.emp.end)
#do gkv.x and gkv.y have the same values?
sum(total_employ$gkv.x != total_employ$gkv.y) #0 -> gkv.x and gkv.y have the same values, delete gkv.y and rename gkv.x to gkv
total_employ <- total_employ %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

nrow(total_employ) - nrow(total_stamm) 
#after the filter, there are 42 rows less than before
missing_rows <- total_stamm %>%
  anti_join(total_employ, by = c("pragmaid", "date.qwt.start", "date.qwt.end")) #für 42 Zeilen gibt es keine employment Daten (-> Lücken in den Daten, siehe unten), diese werden exkludiert (aktiver Versichertenstatus ist Inklusionskriterium)

total_employ$emp.type <- as.factor(total_employ$emp.type)
total_employ$sex <- as.factor(total_employ$sex)
total_employ$nationality <- as.factor(total_employ$nationality)
total_employ$ward <- as.factor(total_employ$ward)
total_employ$source <- as.factor(total_employ$source)

```
# Sind fehlende Daten für Employment auf Unterbrechungen in Versichertenzeiten zurückzuführen?
```{r check_missing_employment}
#check if missing employment data is due to interruptions in insured periods
check_missing <- left_join(missing_rows, insurance_periods, by = c("pragmaid")) %>%
  select(pragmaid, date.qwt.start, date.qwt.end, date.ins.start, date.ins.end, gkv.x, gkv.y) 

sum(check_missing$gkv.x != check_missing$gkv.y) #0 -> gkv.x and gkv.y have the same values
#QWT Zeitraum liegt tatsächlich außerhalb des Versichertenzeitraums, daher fehlen auch die Employment Daten. Wieso? 
``` 
# Hinzufügen von Diagnose-Daten

```{r add_diagnoses}
sum(is.na(all_diagnoses$pragmaid)) #158

diagnoses_filtered <- all_diagnoses %>% 
  filter(pragmaid %in% total_employ$pragmaid) #keep only rows that are also in total_employ

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(diagnoses_filtered, pragmaid)) #0, all patients have diagnoses

table(diagnoses_filtered$icd_type)

diagnoses_filtered <- diagnoses_filtered %>% 
  filter(icd_type %in% c("confirmed", "primary", "secondary", "any")) %>%
  mutate(length_diag = as.integer(difftime(as.Date(date.diag.end), as.Date(date.diag.start), units = "days"))) 

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(diagnoses_filtered, pragmaid)) #0, all patients have diagnoses that fulfill the criteria

summary(diagnoses_filtered$length_diag)
#plot histogram of length_diag
ggplot(diagnoses_filtered, aes(x = length_diag)) + geom_histogram(binwidth = 1) +
  facet_wrap(~setting) +
  scale_x_continuous(limits = c(0, 100))

#show cases with NA in length_diag
diagnoses_filtered %>% 
  filter(is.na(length_diag)) %>%
  select(pragmaid, icd, icd_type, setting, date.diag.start, date.diag.end)

#delete length_diag
diagnoses_filtered <- select(diagnoses_filtered, -length_diag)

sum(is.na(diagnoses_filtered$date.diag.start)) #20
sum(is.na(diagnoses_filtered$date.diag.end)) #17
sum(is.na(diagnoses_filtered$setting)) #0
sum(is.na(total_employ$date.qwt.start)) #0
sum(is.na(total_employ$date.qwt.end)) #0

#if date.diag.end is NA, set it to date.diag.start
#diagnoses_filtered <- diagnoses_filtered %>% 
#  mutate(date.diag.end = ifelse(is.na(date.diag.end), date.diag.start, date.diag.end))
#if date.diag.start is NA, set it to date.diag.end
#diagnoses_filtered <- diagnoses_filtered %>% 
#  mutate(date.diag.start = ifelse(is.na(date.diag.start), date.diag.end, date.diag.start))

#add diagnoses to total_employ and filter for diagnoses according to time criteria and exclude alcohol diagnoses
#total_diag_all <- left_join(total_employ, diagnoses_filtered, by = c("pragmaid", "gkv")) %>%
#  filter(
#    (date.diag.start <= date.qwt.start & date.diag.end >= (date.qwt.end - months(1))) |  # Diagnosestart muss vor oder gleich QWT-Start liegen und Diagnose muss noch bis mindestens 1 Monat vor QWT-Ende laufen
#    (is.na(date.diag.end) & date.diag.start >= (date.qwt.start - months(1)) & date.diag.start <= #date.qwt.start) |  # Falls date.diag.end NA ist, darf date.diag.start nur bis zu einem Monat vor QWT-Start und maximal gleich QWT-Start liegen
#    (is.na(date.diag.start) & date.diag.end >= (date.qwt.end - months(1)) & date.diag.end <= (date.qwt.end + weeks(1)))  # Falls date.diag.start NA ist, darf date.diag.end nur bis zu einem Monat vor und eine Woche nach QWT-Ende liegen
#  ) %>%
#  filter(icd.alc == "FALSE") %>%
#  distinct(pragmaid, qwt_id, icd, .keep_all = TRUE)

#neues Zeitfenster für Diagnosen
total_diag_all <- left_join(total_employ, diagnoses_filtered, by = c("pragmaid")) 
#are gkv.x and gkv.y the same?
sum(total_diag_all$gkv.x != total_diag_all$gkv.y) # there are 518 rows where gkv.x and gkv.y are not the same
nrow(distinct(total_diag_all, pragmaid, qwt_id)) #3815

total_diag_all_filtered <- total_diag_all %>%
  filter(
    #Ambulante Diagnosen (Dauer: 1 Quartal) dürfen nicht später zurückliegend als 2 Quartale vor QWT-Start gestellt worden sein und maximal gleich QWT-Start liegen
     date.diag.start >= (date.qwt.start - days(180)) & date.diag.start <= date.qwt.start)
#Arbeitsdefinition, für stationäre Diagnosen (bzw. alle anderen settings) muss Eingrenzung noch angepasst werden
sum(total_diag_all_filtered$gkv.x != total_diag_all_filtered$gkv.y) #0, so cases where gkv.x and gkv.y are not the same are filtered out -> okay, delete gkv.y and rename gkv.x to gkv
total_diag_all_filtered <- total_diag_all_filtered %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

nrow(distinct(total_diag_all_filtered, pragmaid, qwt_id)) #3815

nrow(distinct(total_diag_all, pragmaid, qwt_id)) - nrow(distinct(total_diag_all_filtered, pragmaid, qwt_id)) #0

check_missing_diag <- total_diag_all %>% 
  anti_join(total_diag_all_filtered, by = c("pragmaid", "qwt_id", "icd", "date.diag.start", "date.diag.end", "setting", "icd.alc")) %>%
  select(pragmaid, qwt_id, icd, date.diag.start, date.diag.end, date.qwt.start, date.qwt.end, setting) # -> okay

#----------------------------------------------
# Testen mit einem kleinen Beispiel-Datensatz
test_df <- data.frame(
  pragmaid = 1:6,
  gkv = c("aok", "aok", "dak", "dak", "dak", "aok"),
  date.qwt.start = as.Date(c('2021-01-01', '2021-06-01', '2021-07-01', '2021-10-01', '2022-01-01', '2022-04-01')),
  setting = c("outpatient", "inpatient", "outpatient", "inpatient", "outpatient", "outpatient"),
  date.diag.start = as.Date(c('2019-07-01', '2020-11-01', '2021-03-01', '2021-09-01', '2021-11-01', '2022-01-01')),
  qwt_id = 1:6,
  icd = c("A", "B", "C", "D", "E", "F")
)

result <- test_df %>%
  mutate(test_column = case_when(
    (setting == "outpatient" & date.diag.start >= (date.qwt.start - months(6)) & date.diag.start <= date.qwt.start) |
    (setting != "outpatient" & date.diag.start >= (date.qwt.start - months(6)) & date.diag.start <= date.qwt.start) ~ 1,
    TRUE ~ 0
  ))
#----------------------------------------------

nrow(distinct(total_employ, pragmaid)) - nrow(distinct(total_diag_all_filtered, pragmaid)) #0 patients do not have any diagnoses that fulfill the criteria -> die Berücksichtigung von NAs in Filterung ändert hier nichts
nrow(distinct(total_employ, pragmaid, qwt_id)) - nrow(distinct(total_diag_all_filtered, pragmaid, qwt_id)) # 0 patient - QWT combinations do not have any diagnoses that fulfill the criteria -> die Berücksichtigung von NAs in Filterung ändert hier nichts


total_diag_all_filtered$id_pragma_qwt <- paste(total_diag_all_filtered$pragmaid, total_diag_all_filtered$qwt_id, sep = "_")

comorb <- comorbidity::comorbidity(x=total_diag_all_filtered, id = "id_pragma_qwt",
                                code = "icd",map="elixhauser_icd10_quan",
                                assign0 = T,tidy.codes = T)

comorb_sum <- comorb %>%
  #new column with row sums using all columns except the first one and "alcohol"
  mutate(elix_sum = rowSums(select(., -1, -alcohol))) %>%
  select(id_pragma_qwt, elix_sum)
        

nrow(distinct(total_employ, pragmaid, qwt_id)) - nrow(distinct(comorb_sum, id_pragma_qwt))
# 0 patients - QWT combinations do not have any diagnoses that fulfill the criteria
total_employ$id_pragma_qwt <- paste(total_employ$pragmaid, total_employ$qwt_id, sep = "_")

total_diag <- left_join(total_employ, comorb_sum, by = "id_pragma_qwt")

#are there missings? 
nrow(total_employ) - nrow(total_diag) #0
sum(is.na(total_diag$elix_sum)) #0 missings in n_diagnoses_woa
```

```{r check_ndiagnoses}
#plot histogram of number of diagnoses
ggplot(total_diag, aes(x = elix_sum)) + geom_histogram(binwidth = 1)
summary(total_diag$elix_sum)
```
# Hinzufügen von Pflegegraden
```{r add_pflegegrad}
str(fosterage)
table(fosterage$fost.degree, useNA = "always")
# sowohl Pflegegrade (PG) als auch Pflegestufen (PS). Pflegegrade sind ab 2017 gültig, Pflegestufen bis 2016. Wie Pflegestufen in Pflegegrade umrechnen?
min(qwt$date.qwt.start) #2015-12-11

unique(qwt$date.qwt.start) %>% sort() #5 QWTs wurden vor 2016 begonnen

#Quelle: https://www.gkv-spitzenverband.de/media/dokumente/service_1/Pflegebegutachtung_2017_von_Pflegestufen_zu_Pflegegraden.pdf
# ohne PEA funktioniert Umrechnung nicht eindeutig. Daher wird die Variable zu Pflegebedarf vorhanden/nicht vorhanden kodiert

#conversion_table_PSPG <- c("PS0" = "PG2",
#                      "PS1" = "PG2",
#                      "PS2" = "PG3",
#                      "PS3" = "PG4",
#                      "PSH" = "PG5")

#fosterage <- fosterage %>% 
#  mutate(fost.degree = recode(fost.degree, !!!conversion_table))

fost_filtered <- fosterage %>% 
  filter(pragmaid %in% total_diag$pragmaid)
###NOT WORKING -> to be finished!
nrow(distinct(total_diag, pragmaid)) - nrow(distinct(fost_filtered, pragmaid))
#1660 patients do not have fosterage data
#248 patients have fosterage data

#if pragmaid from total_diag is in fosterage and the respective QWT is within the fosterage period, add fosterage to total_diag. if not, set fosterage to NA
total_fost_all <- left_join(total_diag, fost_filtered, by = "pragmaid") 

nrow(distinct(total_fost_all, pragmaid)) #1908 patients -> correct

total_fost_all_filtered <- total_fost_all %>%
  filter((date.qwt.start >= date.fost.start & is.na(date.fost.end)) | (date.qwt.start >= date.fost.start & date.qwt.start <= date.fost.end))
nrow(distinct(total_fost_all_filtered, pragmaid)) #98 patients do have fosterage data that is within the QWT period
nrow(distinct(total_fost_all_filtered, pragmaid, qwt_id))# 169 qwts among 98 patients with fosterage data that is within the QWT period
sum(total_fost_all_filtered$gkv.x != total_fost_all_filtered$gkv.y) #0 -> gkv.x and gkv.y are the same, delete gkv.y and rename gkv.x to gkv
total_fost_all_filtered <- total_fost_all_filtered %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

# check data that is filtered out
check_missing_fost <- total_fost_all %>% 
  anti_join(total_fost_all_filtered, by = c("pragmaid", "date.qwt.start", "date.qwt.end", "date.fost.start", "date.fost.end")) %>%
  select(pragmaid, date.qwt.start, date.qwt.end, date.fost.start, date.fost.end, fost.degree) # -> okay



# add total_fost_all_filtered to total_diag and set fosterage to NA if no fosterage data is available
total_fost <- total_diag %>%
  left_join(total_fost_all_filtered %>% select(id_pragma_qwt, fost.degree), by = "id_pragma_qwt") %>%
  mutate(fost.degree_bin = as.factor(ifelse(is.na(fost.degree), "nein", "ja")))

total_fost$fost.degree <- as.factor(total_fost$fost.degree)
table(total_fost$fost.degree, useNA = "always")
table(total_fost$fost.degree_bin, useNA = "always")
nrow(total_fost) - sum(is.na(total_fost$fost.degree)) #check: 169 qwts with fosterage degree -> okay

```

# Hinzufügen von Medikation

```{r add_medication}

med_filtered <- medications %>% 
  filter(pragmaid %in% total_fost$pragmaid)

nrow(distinct(total_fost, pragmaid)) - nrow(distinct(med_filtered, pragmaid)) #44 patients do not have medication data

#add med_filtered to total_fost
total_med_all <- left_join(total_fost, med_filtered, by = "pragmaid")

nrow(distinct(total_med_all, pragmaid)) #1908 patients

total_med_all_filtered <- total_med_all %>%
# only keep medication data that happend during the 3 months before the QWT
  filter(date.medi.disp >= (date.qwt.start - days(30)) & date.medi.disp <= date.qwt.start) %>%
  filter(ATC != "")

nrow(distinct(total_med_all_filtered, pragmaid, qwt_id)) # 2358 qwts with medication data during 3 months before
nrow(distinct(total_fost, pragmaid, qwt_id)) - nrow(distinct(total_med_all_filtered, pragmaid, qwt_id)) # 1457 qwts without medication data during 3 months before

sum(total_med_all_filtered$gkv.x != total_med_all_filtered$gkv.y) #0 -> gkv.x and gkv.y are the same, delete gkv.y and rename gkv.x to gkv

total_med_all_filtered <- total_med_all_filtered %>% 
  select(-c(gkv.y, REZ_ID, LANR_FAGS, date.medi.presc, PZN_ANZ, DDD1000_PK)) %>%
  rename(gkv = gkv.x)

missing_med <- total_med_all %>% 
  anti_join(total_med_all_filtered, by = c("pragmaid", "date.qwt.start", "date.qwt.end", "date.medi.disp")) %>%
  select(pragmaid, date.qwt.start, date.qwt.end, date.medi.disp) # -> okay
rm(missing_med)

#calculate number of full ATC and level 2 ATC codes
total_med_sum <- total_med_all_filtered %>%
  group_by(id_pragma_qwt) %>%
  mutate(Level2_ATC = substr(ATC, 1, 3)) %>%
  summarize(ndistinctATClevel2 = n_distinct(Level2_ATC), 
            ndistinctATC = n_distinct(ATC))

total_med <- left_join(total_fost, total_med_sum, by = "id_pragma_qwt")
#set NAs in ndistinct to 0
total_med <- total_med %>%
  mutate(ndistinctATC = ifelse(is.na(ndistinctATC), 0, ndistinctATC)) %>%
  mutate(ndistinctATClevel2 = ifelse(is.na(ndistinctATClevel2), 0, ndistinctATClevel2)) %>%
  mutate(polymedi = as.factor(ifelse(ndistinctATC >= 6, "ja", "nein"))) %>%
  mutate(polymedi_level2 = as.factor(ifelse(ndistinctATClevel2 >= 5, "ja", "nein")))

summary(total_med$ndistinctATC)
hist(total_med$ndistinctATC)

summary(total_med$ndistinctATClevel2)
hist(total_med$ndistinctATClevel2)

table(total_med$polymedi)
table(total_med$polymedi_level2)
```

# Auswahl relevanter Variablen
```{r select_vars}
total_med <- total_med %>% 
  select(-c(KH_FALL_ID, date.kkh.start, date.kkh.end, date.qwt.start, date.qwt.end, date.emp.start, date.emp.end, id_pragma_qwt, fost.degree, source, icd.primary, icd.secondary, icd.admission, icd.other, died, date.death, ward))
```

#Speicherplatz freigeben
```{r save_data}
#alle Datenfiles die "all" oder "check" oder "missing" im Namen haben, können gelöscht werden
#identifiziere alle Objekte, die gelöscht werden können
objects <- ls()
objects <- objects[grepl("all|check|missing", objects)]
#lösche alle Objekte
rm(list = objects)
#free unused memory
gc()
```

# Überpfrüfung der Daten vor Modellierung
```{r check_data}
#check for missings
summary(total_med)
anyNA(total_med) #no NAs
total_med$gkv <- as.factor(total_med$gkv)
total_med$pragmaid <- as.factor(total_med$pragmaid)

#check for outliers
boxplot(total_med$n_days) # not outliers
boxplot(total_med$qwt_id) # some patients did 21 qwts -> remove outliers?

#ckeck for multicollinearity
logit_model <- glm(treat_dur_bin ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + ndistinctATClevel2, data = total_med, family = binomial)
car::vif(logit_model) #generalized variance inflation factor
#"A consequence is that when using aGSIF, we must take the square-root of our rules of thumb for what is a large value – aGSIF values above √2.5 (1.6) may be of concern, and #values above √5 or √10 (2.2 or 3.2) are indicative of a more serious problem"
# no problems of multicollinearity

#Plausi check ndistinct ATC (should increase with elix_sum)
ggplot(total_med, aes(x = elix_sum, y = ndistinctATC)) + geom_point() + geom_smooth(method = "lm")
#correlation between elix_sum and ndistinctATC?
cor(total_med$elix_sum, total_med$ndistinctATC) #0.50 

ggplot(total_med, aes(x = elix_sum, y = ndistinctATClevel2)) + geom_point() + geom_smooth(method = "lm")
#correlation between elix_sum and ndistinctATClevel2?
cor(total_med$elix_sum, total_med$ndistinctATClevel2) #0.51

```

# Aufstellen eines Modells zur Vorhersage von unpl_drop
## Logistisches Modell zur Vorhersage von dichotomisierter Behandlungsdauer (unter vs. über 20 Tage)
```{r model_glmm}

#model1.1 <- glmmTMB(treat_dur_bin ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + polymedi + (1|gkv/pragmaid), data = total_med, family = binomial)

#summary(model1.1)
```

## Ordinales Modell zur Vorhersage von Behandlungsdauer in drei Kategorien
```{r model_clmm}
# Modellvergleich mit und ohne GKV
#model1.2 <- clmm(treat_dur_cat ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + polymedi + gkv + (1|pragmaid), data = total_med)

#summary(model1.2)
#AIC(model1.2)
#BIC(model1.2)
#logLik(model1.2)

#model1.3 <- clmm(treat_dur_cat ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + polymedi + (1|pragmaid), data = total_med)

#print(model1.3)
#summary(model1.3)
#AIC(model1.3)
#BIC(model1.3)
#logLik(model1.3)

#Modell ohne GKV ist besser
```

### Welche Variable für Medikation ergibt das beste Modell?
```{r model_med}
#Modell mit ndistinctATC

#model2.1 <- clmm(treat_dur_cat ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + polymedi + (1|pragmaid), data = total_med)

#model2.2 <- clmm(treat_dur_cat ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + polymedi_level2 + (1|pragmaid), data = total_med)

model2.3 <- clmm(treat_dur_cat ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + ndistinctATClevel2 + (1|pragmaid), data = total_med)

#model2.4 <- clmm(treat_dur_cat ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + ndistinctATC + (1|pragmaid), data = total_med)

#model2.5 <- clmm(treat_dur_cat ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + (1|pragmaid), data = total_med)
#plomedikation mitaufzunehmen macht das Modell kaum/gar nicht besser, je nach Kriterium sogar schlechter

#compare models
#for (i in 1:5) {
#  print(paste("Model", i))
#  print(AIC(get(paste("model2.", i, sep = ""))))
#  print(BIC(get(paste("model2.", i, sep = ""))))
#  print(logLik(get(paste("model2.", i, sep = ""))))
#}

summary(model2.3)
save(model2.3, file = "modeloutput_CLMM_PRAGMA_dropout.RData")
#summary(model2.5) #elix_sum ist kein signifikanter Prädiktor, egal ob Medikation im Modell ist oder nicht
#[1] "Model 4"
#[1] 7021.353
#[1] 7102.56
#'log Lik.' -3497.677 (df=13)                

#[1] "Model 2"
#[1] 7020.536
#[1] 7101.743 -> erniedrigen auf 5 medi -> schlechterer fit

#Model mit 30 Tage Look Back Window und ndistinctATClevel2 hat das beste AIC, laut BIC (restriktiver gegenüber weiteren Prädiktoren) ist das Modell ohne Medikation am besten
```
#Multinomiale Modelle
```{r multinom_models}
#nur Intercept und random effects
model3.0 <- mblogit(formula = treat_dur_cat ~ 1, random = ~ 1 | pragmaid, data = total_med)
summary(model3.0)
getSummary.mblogit(model3.0)
model3.1 <- mblogit(formula = treat_dur_cat ~ sex, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.1)
model3.2 <- mblogit(formula = treat_dur_cat ~ sex + age, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.1)
getSummary.mblogit(model3.2) #Model 2 ist besser
model3.3 <- mblogit(formula = treat_dur_cat ~ sex + age + qwt_id, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.3) #Model 3 ist besser
model3.4 <- mblogit(formula = treat_dur_cat ~ sex + age + qwt_id + nationality, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.4) #Modell 3 (treat_dur_cat ~ sex + age + qwt_id) scheint insgesamt die beste Modellanpassung zu bieten, basierend auf AIC und BIC, trotz der geringfügigen Verbesserung der Pseudo-R²-Werte durch Modell 4.
#Modell 4 (treat_dur_cat ~ sex + age + qwt_id + nationality) bietet die besten Pseudo-R²-Werte und die niedrigste Deviance, aber es hat einen leicht höheren AIC und BIC im Vergleich zu Modell 3. Daher wird nationality nicht in das endgültige Modell aufgenommen.
model3.5 <- mblogit(formula = treat_dur_cat ~ sex + age + qwt_id + emp.type, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.5) #Modell 5 erklärt die Daten am umfassendsten und bietet insgesamt die beste Passung, basierend auf AIC, BIC, Pseudo-R² und Deviance. Allerdings hat Modell 3 ein besseres BIC. 
model3.6 <- mblogit(formula = treat_dur_cat ~ sex + age + qwt_id + emp.type + gkv, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.6) #Modell 6 ist besser
model3.7 <- mblogit(formula = treat_dur_cat ~ sex + age + qwt_id + emp.type + gkv + elix_sum, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.7) #Komorbidität verbessert Modell nicht und hat auch keinen siginifikanten Erklärungswert
model3.8 <- mblogit(formula = treat_dur_cat ~ sex + age + qwt_id + emp.type + gkv + fost.degree_bin, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.8) #Modell 6 ist besser
model3.9 <- mblogit(formula = treat_dur_cat ~ sex + age + qwt_id + emp.type + gkv + ndistinctATClevel2, random = ~ 1 | pragmaid, data = total_med)
getSummary.mblogit(model3.9) #Modell 6 ist besser, interessant ist aber, dass aus den dtrei Prädiktoren, die die Krankheitslast beschreiben (forst_degree, elix_sum, ndistinctATClevel2), ndistinctATClevel2 den besseren model fit bietet nach allen Kriterien zufolge


```
# Interpretation der festen Effekte

- 0.56 (Intercept) ist geschätzt als log odds für eine Behandlungsdauer von mind. 20 Tagen bei einer Frau, die 0 Jahre alt ist und ihre 0. QWT hat -> Log Odds negativ -> Behandlungen von mind. 20 Tagen sind unwahrscheinlicher als unter 20 Tagen

Negativer Koeffizienten für Geschlecht:männlich -> Männer haben eine geringere Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen als Frauen

negativer Koeffizient für QWT_ID -> mit fortlaufender QWT_ID sinkt die Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen, d. h., ein höherer `qwt_id`-Wert erhöht die Wahrscheinlichkeit für kürzere Aufenthalte.

Negativer Koeffizienten für emp.type:unemployed -> Arbeitslosigkeit senkt Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen im Vergleich zu bestehendem Arbeitsverhältnis

Negativer Koeffizienten für n_diagnoses_wo -> es scheint so als ob Wahrscheinlichkeit für Behandlungen von mind. 20 Tagen sinkt, wenn Anzahl der Diagnosen steigt -> **wird der potenzielle Einfluss von einer bestimmten Diagnose getrieben?**

Die Varianz des Interzepts für die zufälligen Effekte beträgt 0.33. Das bedeutet, dass es eine gewisse Streuung zwischen den Patient:innen gibt, die nicht durch die festen Effekte erklärt wird.