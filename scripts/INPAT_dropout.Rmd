---
title: "SAB_dropout"
author: "Anna Schranz"
date: "2024-08-07"
output: 
  html_document:
    code_folding: hide
---

# Einflussfaktoren für eine irreguläre Beendigung einer stationären Alkoholbehandlung (SAB)


Bei SAB handelt es sich um stationäre, alkoholbezogene Kontakte (Haupt- oder Fachabteilungsdoiagnose Alkohol), die KEIN qualifizierter Entzug sind. OPS Codes: 9-60x; 9-61x; 9-62x oder 9-63x, aber nicht 8-985 oder 9-647. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
```

## Set Up

```{r essentials}
# clean workspace
rm(list=ls())
packages <- c("data.table", "tidyverse", "ggplot2", "comorbidity", "car", "glmmTMB", "lme4", "ordinal", "export", "mclogit", "sjPlot", "see", "nnet", "ggeffects", "DHARMa", "effects", "performance")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Load packages
invisible(lapply(packages, library, character.only = TRUE))

# current date
DATE <- format(Sys.Date(), "%Y%m%d")

# output folders
folder_table <- file.path("..", "output/tables")
folder_plot <- file.path("..", "output/figures")

if (!file.exists(folder_table)) {
  dir.create(folder_table, recursive = TRUE)
}

if (!file.exists(folder_plot)) {
  dir.create(folder_plot, recursive = TRUE)
}
```

## Daten Import

```{r data_import}
print(getwd())
datapath <- file.path("..", "input") 
#read in all RDS-files in datapath 
filenames <- list.files(datapath, pattern = "\\.rds$", full.names = T)

names <- c("pragma_id_GKV", "all_diagnoses", "medications", "employment", "fosterage", "income", "insurance_periods", "SAB_OPS", "SAB", "QEB_OPS", "QEB", "reha", "reha_new")

if (length(filenames) != length(names)) {
  stop("Die Anzahl der Dateien stimmt nicht mit Anzahl names überein.")
}

#save all files as separate dataframes
ldf <- lapply(filenames, readRDS)
names(ldf) <- names[1:length(ldf)]
print(names(ldf))
list2env(ldf, envir = .GlobalEnv) #save all dataframes in global environment
```

## Daten vorbereiten

### Daten Struktur
```{r data_structure}
str(SAB)
SAB$n.days <- as.integer(SAB$n.days)

# convert pragmaid to factor in all dataframes
# harmonise column names


ldf <- lapply(names(ldf), function(df_name) {
  df <- ldf[[df_name]]
  
  if ("pragmaid" %in% colnames(df)) {
    df <- df %>%
      mutate(pragmaid = as.factor(pragmaid))
  }
  
  if (df_name %in% c("reha_new", "reha", "SAB", "QEB")) {
    
    date_columns <- grep("^date\\.(inpat|qwt|drvreha|reha)\\.(start|end)$", colnames(df), value = TRUE)
    
    if (length(date_columns) > 0) {
      new_names <- gsub("^date\\..*\\.", "date.treat.", date_columns)
      df <- df %>%
        rename_with(~ new_names, all_of(date_columns))
      
      treatment_types <- gsub("^date\\.(.*)\\..*$", "\\1", date_columns)  
      unique_treatments <- unique(treatment_types)
      print(treatment_types)
      df <- df %>%
        mutate(treatment = factor(unique_treatments[1])) 
    }
  }
    
      # rename inpat_id to SAB_id
      if ("inpat_id" %in% colnames(df)) {
        df <- df %>%
          rename(SAB_id = inpat_id)
      }
      
      # rename qwt_id to QEB_id
      if ("qwt_id" %in% colnames(df)) {
        df <- df %>%
          rename(QEB_id = qwt_id)
      }

  # mutate values in treatment column (inpat -> SAB, qwt -> QEB)
  if ("treatment" %in% colnames(df)) {
    df <- df %>%
      mutate(treatment = case_when(
        as.character(treatment) == "inpat" ~ "SAB",
        as.character(treatment) == "qwt" ~ "QEB",
        TRUE ~ as.character(treatment)
      )) %>%
      mutate(treatment = factor(treatment))
  }
  
  return(df)
})

# check 
str(ldf)
names(ldf) <- names[1:length(ldf)]

list2env(ldf, envir = .GlobalEnv)
```

### Check der Behandlungszeiträume

Direkt ineiander übergehende SAB:
```{r check_immconsec}
# DIREKTE ANSCHLÜSSE
#wenn sich ein SAB direkt an das vorangehende SAB anschließt, sollen beide zusammengefasst werden

SAB <- SAB %>%
 arrange(pragmaid, date.treat.start) %>%
 group_by(pragmaid) %>%
 mutate(
   direkter_anschluss = (date.treat.start == lag(date.treat.end, default = NULL)) | (date.treat.start == lag(date.treat.end, default = NULL) + 1)) #das Startdatum ist gleich dem Enddatum oder es ist um einen Tag versetzt

table(SAB$direkter_anschluss, useNA = "always") 

#check
SAB %>% arrange(pragmaid, date.treat.start) %>% filter(direkter_anschluss | lead(direkter_anschluss)) %>% select(pragmaid, date.treat.start, date.treat.end)
```

Optional: Direkte Anschlüsse zu einem Treatment zusammenfassen

```{r combine_consectreatments}

SAB <- SAB %>%
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(
    date.treat.start = case_when(
      direkter_anschluss ~ lag(date.treat.start),
      TRUE ~ date.treat.start
    )
  ) %>%
  filter(is.na(lead(direkter_anschluss)) | !lead(direkter_anschluss)) %>%  # keep only those rows where `direkter_anschluss` of the next row is FALSE
  ungroup()
```

Gibt es Überlappungen in den Behandlungszeiträumen innerhalb einer Person?

```{r check_overlaps}
SAB$overlap <- FALSE

SAB <- SAB %>%
  group_by(pragmaid) %>%
  mutate(overlap = sapply(1:n(), function(i) {
    any(date.treat.start[i] < date.treat.end[-i] & date.treat.end[i] > date.treat.start[-i])
  }))

table(SAB$overlap, useNA = "always")

overlapping_IDs <- SAB %>% filter(overlap == TRUE) %>% pull(pragmaid) %>% unique()

# plot overlaps
ggplot(SAB %>% filter(pragmaid %in% overlapping_IDs),
       aes(y = pragmaid)) +
  geom_segment(aes(x = date.treat.start,
                   xend = date.treat.end,
                   yend = pragmaid,
                   alpha = as.factor(overlap)),
               size = 5) +
  scale_alpha_manual(values = c(`FALSE` = 0.3, `TRUE` = 1)) +
  labs(x = "Date", y = "Pragma ID") +
  theme_minimal()
```

## Overlaps in treatments entfernen
```{r remove_overlaps}

cases_to_remove <- SAB %>%
  filter(overlap == TRUE) %>%
  group_by(pragmaid) %>%
  arrange(pragmaid, date.treat.start) %>%
  mutate(group_overlap = cumsum(
      coalesce(
        as.logical(date.treat.start > lag(date.treat.end, n = 1, default = first(date.treat.start)) &
                   date.treat.start > lag(date.treat.end, n = 2, default = first(date.treat.start)) &
                   date.treat.start > lag(date.treat.end, n = 3, default = first(date.treat.start))
        ), TRUE
      ))) %>%
  group_by(pragmaid, group_overlap) %>%
  mutate(
    max_n_days = max(n.days),  # maximum per group
    keep = case_when(
      n.days == max_n_days & row_number() == which.max(n.days) ~ TRUE,  # Behalte die erste Zeile mit max_n_days
      n.days == max_n_days ~ FALSE,                                   # Andere mit max_n_days auf FALSE setzen
      TRUE ~ FALSE                                                    # Kleinere Werte ebenfalls auf FALSE
    )
  )

cases_to_remove %>% arrange(pragmaid, date.treat.start) %>% select(pragmaid, date.treat.start, date.treat.end, n.days, ENTL301, overlap, group_overlap, keep, max_n_days)

#common columns in cases_to_remove and SAB
common_cols <- intersect(names(cases_to_remove), names(SAB))

# n of cases to remove
sum(cases_to_remove$keep == FALSE)

#SAB: remove cases with keep == "remove" in cases_to_remove
SAB <- SAB %>%
  left_join(cases_to_remove, by = common_cols) %>%
  filter(is.na(keep) | keep == TRUE) %>%
  select(-c(overlap, group_overlap, keep, direkter_anschluss))

```

## Definition "irreguläre Beendigung" mittels ENTLASS301

```{r recode_ENTL}
labels_entl301 <- c(
  "1" = "regulär",
  "2" = "beendet, nachstat. Beh. vorgesehen",
  "3" = "aus sonstigen Gründen beendet",
  "4" = "gegen ärztlichen Rat beendet",
  "6" = "Verlegung in ein anderes Krankenhaus",
  "7" = "Tod",
  "9" = "Rehaeinrichtung",
  "10" = "Pflegeeinrichtung",
  "14" = "aus sonst. Gründen beend., nachstat. Beh. Vorges.",
  "15" = "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.",
  "17" = "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG",
  "22" = "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."
)

SAB$ENTL301 <- factor(SAB$ENTL301, levels = names(labels_entl301), labels = labels_entl301)

table(SAB$ENTL301, useNA = "always")

#Einteilung der ENTLASS Gründe in "irreguläre Beendigung" (1 = ja; 2 = nein)
SAB <- SAB %>% 
  filter(ENTL301 != "Tod") %>%
  mutate(unpl_drop = factor(case_when(
  ENTL301 %in% c("aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.") ~ 1,
  ENTL301 %in% c("regulär", "beendet, nachstat. Beh. vorgesehen", "Verlegung in ein anderes Krankenhaus", "Rehaeinrichtung", "Pflegeeinrichtung",
                 "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh.") ~ 0,
  TRUE ~ NA_real_), levels = c(0, 1), labels = c("nein", "ja")))

table(SAB$unpl_drop, useNA = "ifany")
prop.table(table(SAB$unpl_drop, useNA = "ifany"))
ggplot(SAB, aes(x = unpl_drop, y = n.days)) + geom_violin() + geom_boxplot(width = 0.1) + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + ylim(NA, 75)

#Fallzahl
SAB %>% summarise(n = n(), npragmaid = n_distinct(pragmaid))

```

## Definition der Prädiktoren

### SAB_id (Behandlungserfahrung SAB)

```{r check_QEB_id}
# does the SAB_id increases with increasing date.treat.start?
SAB_check <- SAB %>% 
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(SAB_id_ordered = row_number()) %>%
  select(pragmaid, SAB_id, SAB_id_ordered, date.treat.start, date.treat.end) #SAB_id was unordered before. therefore, replace SAB_id with SAB_id_ordered

#correct SAB_id, so that it is ordered by date.treat.start
SAB <- SAB %>% 
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(SAB_id = row_number() - 1) %>%
  mutate(treat_dur_cat = factor(case_when(
  #more than or 21 days in treatment
  n.days >= 21 ~ 3,
  #between 7 and 20 days (inclusive)
  n.days >= 7 & n.days < 21 ~ 2,
  #between 0 and 6 days (inclusive)
  n.days >= 0 & n.days < 7 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("1-6 Tage","7-20 Tage", "21+ Tage")))

```

### Hinzufügen der Stammdaten - SEX + AGE + NATIONALITY

```{r add_stammdaten}
#match pragma_id_GKV with SAB based on pragma_id to get sex and age information 
total_stamm <- left_join(SAB, pragma_id_GKV, by="pragmaid")

table(total_stamm$gkv.x, useNA = "always")
table(total_stamm$gkv.y, useNA = "always") # 7 cases that are insured by both AOK and DAK (this information is not needed for the analysis, so keep only the insurence information from gkv.x)

total_stamm <- total_stamm %>% 
  select(c(-hivid, -gkv.id, -dak.id, -aok.id, - gkv.y)) %>%
  mutate(age = as.integer(substr(date.treat.start, 1, 4)) - yob) %>% #calculate age at the beginning of the SAB
  rename(gkv = gkv.x) #rename gkv.x to gkv

table(total_stamm$sex, useNA = "always") # 0 NAs
summary(total_stamm$age) # 0 NAs
```

### Hinzufügen Emplyoment Status

```{r add_employment}
nrow(distinct(total_stamm, pragmaid, SAB_id)) 
employ_unfiltered <- left_join(total_stamm, employment, by = "pragmaid")

table(employ_unfiltered$gkv.x, useNA = "always")
table(employ_unfiltered$gkv.y, useNA = "always") #same

employ_unfiltered <- employ_unfiltered %>% 
  select(- gkv.y) %>%
  rename(gkv = gkv.x) #rename gkv.x to gkv

SAB_employ <- employ_unfiltered %>%
  filter(date.treat.start >= date.emp.start & date.treat.start <= date.emp.end)

nrow(distinct(SAB_employ, pragmaid, SAB_id))
nrow(SAB_employ) - nrow(total_stamm) # there are 30 cases less than before - why?

missing_rows <- total_stamm %>%
  anti_join(SAB_employ, by = c("pragmaid", "SAB_id"))

employment %>% filter(pragmaid %in% missing_rows$pragmaid) %>% group_by(pragmaid) # no employment data for the SAB period - why? 
```

#### Einschub: Sind fehlende Daten für Employment auf Unterbrechungen in Versichertenzeiten zurückzuführen?

```{r check_missing_employment}
#check if missing employment data is due to interruptions in insured periods
check_missing <- left_join(missing_rows, insurance_periods, by = c("pragmaid")) %>%
  select(pragmaid, date.treat.start, date.treat.end, date.ins.start, date.ins.end, gkv.x) 

#filter cases where the SAB treatment is covered by insurance
cases_with_valid_ins <- check_missing %>% filter(date.treat.start >= date.ins.start & date.treat.start <= date.ins.end) #there are 8 cases that do have insurance data for the SAB, but have no corresponding employment data. these cases should be kept in the SAB_employ dataset, as they are insured during the SAB period (employment status = NA).

# -> some, but not all cases with missing employment data are due to interruptions in insured periods

#add cases with valid insurance to SAB_employ
SAB_employ <- bind_rows(SAB_employ, total_stamm %>% filter(pragmaid %in% cases_with_valid_ins$pragmaid & date.treat.start %in% cases_with_valid_ins$date.treat.start))

table(SAB_employ$emp.type, useNA = "always") # 8 NAs, so the 8 cases without employment infos, but with insurance are added to the SAB_employ dataset
```

### Hinzufügen von Diagnose-Daten

```{r add_diagnoses}
sum(is.na(all_diagnoses$pragmaid))

table(all_diagnoses$icd_type)

# keep only diagnoses of patients in SAB_employ, with icd_type confirmed, primary, secondary, any and that are not alcohol related
diagnoses_SAB <- all_diagnoses %>% 
  filter(pragmaid %in% SAB_employ$pragmaid) %>% #keep only rows that are in SAB data 
  filter(icd_type %in% c("confirmed", "primary", "secondary", "any")) %>%
  filter(icd.alc == FALSE) %>% #keep only diaignoses that are not alcohol related (as all SAB cases are alcohol related)
  mutate(length_diag = as.integer(difftime(as.Date(date.diag.end), as.Date(date.diag.start), units = "days"))) 

#check
nrow(distinct(SAB_employ, pragmaid)) - nrow(distinct(diagnoses_SAB, pragmaid)) # 2 patients do not have any diagnoses that matches the criteria

summary(diagnoses_SAB$length_diag)

#plot histogram of length_diag
ggplot(diagnoses_SAB, aes(x = length_diag)) + geom_histogram(binwidth = 1) +
  facet_wrap(~setting, scales = "free_y") +
  scale_x_continuous(limits = c(0, 100))

#show cases with NA in length_diag
diagnoses_SAB %>% 
  filter(is.na(date.diag.start)) %>%
  select(pragmaid, icd, icd_type, setting, date.diag.start, date.diag.end)

#delete length_diag
diagnoses_SAB <- select(diagnoses_SAB, -length_diag)

# if date.diag.start is NA, set it to date.diag.end
diagnoses_SAB <- diagnoses_SAB %>% 
  mutate(date.diag.start = dplyr::if_else(is.na(date.diag.start), date.diag.end, date.diag.start))

# join diagnoses with SAB_employ
diagnoses_SAB_employ_alltimes <- left_join(SAB_employ, diagnoses_SAB, by = c("pragmaid")) 

#check
nrow(distinct(diagnoses_SAB_employ_alltimes, pragmaid, SAB_id))

# keep only diagnoses in the timeframe of interest (maximum 2 quarters before SAB start)
diagnoses_SAB_employ_fil <- diagnoses_SAB_employ_alltimes %>%
  filter(
    # outpatient diagnoses (duration: 1 quarter) must not have been made more than 2 quarters before the start of QEB and must not be later than the start of QEB
     date.diag.start >= (date.treat.start - days(180)) & date.diag.start <= date.treat.start)

sum(diagnoses_SAB_employ_fil$gkv.x != diagnoses_SAB_employ_fil$gkv.y) # 33 cases where the insurance information is not the same in the diagnoses data and the SAB data

diagnoses_SAB_employ_fil %>% filter(gkv.x != gkv.y) #these cases all have source == aokdak, so there seems to be an overlap. however, as the gkv information is not that important, we keep the gkv information from the SAB data

diagnoses_SAB_employ_fil <- diagnoses_SAB_employ_fil %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

nrow(distinct(diagnoses_SAB_employ_fil, pragmaid, SAB_id)) #23 cases were excluded as they did not have a diagnosis in the timeframe of interest - they will be added in the end again


# Elixhauser Comorbidity Index

diagnoses_SAB_employ_fil$id_pragma_SAB <- paste(diagnoses_SAB_employ_fil$pragmaid, diagnoses_SAB_employ_fil$SAB_id, sep = "_")

comorb_elix <- comorbidity::comorbidity(x=diagnoses_SAB_employ_fil, id = "id_pragma_SAB",
                                code = "icd",map="elixhauser_icd10_quan",
                                assign0 = T, tidy.codes = T)
print(head(comorb_elix))

comorb_elix_sum <- comorb_elix %>%
  #new column with row sums using all columns except id_pragma_SAB
  mutate(elix_sum = rowSums(select(., -id_pragma_SAB))) %>%
  select(id_pragma_SAB, elix_sum)


nrow(distinct(SAB_employ, pragmaid, SAB_id)) - nrow(distinct(comorb_elix_sum, id_pragma_SAB)) #23 cases, these have to be added to the comorb_elix_sum dataset 

SAB_employ$id_pragma_SAB <- paste(SAB_employ$pragmaid, SAB_employ$SAB_id, sep = "_")

diagnoses_SAB_employ <- left_join(SAB_employ, comorb_elix_sum, by = "id_pragma_SAB")

#are there missings? 
nrow(SAB_employ) - nrow(diagnoses_SAB_employ) #0
sum(is.na(diagnoses_SAB_employ$elix_sum)) #23 missings

#set NAs to 0
diagnoses_SAB_employ <- diagnoses_SAB_employ %>% 
  mutate(elix_sum = replace_na(elix_sum, 0))
```

#### Diagnose Daten Descriptives

```{r check_ndiagnoses}
#plot histogram of number of diagnoses
ggplot(diagnoses_SAB_employ, aes(x = elix_sum)) + geom_histogram(binwidth = 1)
summary(diagnoses_SAB_employ$elix_sum) 
```

### Hinzufügen von Pflegegraden

```{r add_pflegegrad}
table(fosterage$fost.degree, useNA = "always")
# sowohl Pflegegrade (PG) als auch Pflegestufen (PS). Pflegegrade sind ab 2017 gültig, Pflegestufen bis 2016.

fost_SAB <- fosterage %>% 
  filter(pragmaid %in% diagnoses_SAB_employ$pragmaid)

#checks
sum(is.na(fost_SAB$pragmaid)) #0
sum(is.na(fost_SAB$date.fost.start)) #0
nrow(distinct(diagnoses_SAB_employ, pragmaid)) - nrow(distinct(fost_SAB, pragmaid)) #1523 patients do not have fosterage data, 257 do have


fost_diagnoses_SAB_employ_alltimes <- left_join(diagnoses_SAB_employ, fost_SAB, by = "pragmaid")


fost_diagnoses_SAB_employ_fil <- fost_diagnoses_SAB_employ_alltimes %>%
  filter((date.treat.start >= date.fost.start & is.na(date.fost.end)) | (date.treat.start >= date.fost.start & date.treat.start <= date.fost.end))

nrow(distinct(fost_diagnoses_SAB_employ_fil, pragmaid)) # 139 patients do have a pflegegrad/stufe during the beginning of the SAB

# GKV X - GKV Y
sum(fost_diagnoses_SAB_employ_fil$gkv.x != fost_diagnoses_SAB_employ_fil$gkv.y) # 0 cases where the insurance information is not the same in the fosterage data and the SAB data
fost_diagnoses_SAB_employ_fil <- fost_diagnoses_SAB_employ_fil %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x) %>% 
  ungroup()

#add fosterage data to diagnoses_SAB_employ and set fosterage to NA if there is no fosterage data
fost_diagnoses_SAB_employ <- diagnoses_SAB_employ %>% 
  left_join(fost_diagnoses_SAB_employ_fil %>% select(id_pragma_SAB, fost.degree), by = "id_pragma_SAB") %>%
  mutate(fost.degree_bin = as.factor(ifelse(is.na(fost.degree), "nein", "ja"))) 

table(fost_diagnoses_SAB_employ$fost.degree_bin, useNA = "always")

```

### Hinzufügen von Medikation

```{r add_medication}
med_SAB <- medications %>% 
  filter(pragmaid %in% fost_diagnoses_SAB_employ$pragmaid)

#checks
sum(is.na(med_SAB$pragmaid)) 
sum(is.na(med_SAB$date.med.start)) 
nrow(distinct(fost_diagnoses_SAB_employ, pragmaid)) - nrow(distinct(med_SAB, pragmaid))

med_fost_diagnoses_SAB_employ_alltimes <- left_join(fost_diagnoses_SAB_employ, med_SAB, by = "pragmaid")
nrow(distinct(med_fost_diagnoses_SAB_employ_alltimes, pragmaid)) 

med_fost_diagnoses_SAB_employ_fil <- med_fost_diagnoses_SAB_employ_alltimes %>%
  # only keep medication data that happend during the 3 months before the SAB treatment
  filter(date.medi.disp >= (date.treat.start - days(30)) & date.medi.disp <= date.treat.start) %>%
  filter(ATC != "")

nrow(distinct(med_fost_diagnoses_SAB_employ_fil, id_pragma_SAB)) # 1513 SAB have medication data in the timeframe of interest

#GKV X - GKV Y
sum(med_fost_diagnoses_SAB_employ_fil$gkv.x != med_fost_diagnoses_SAB_employ_fil$gkv.y) # 2 cases where the insurance information is not the same in the medication data and the SAB data
med_fost_diagnoses_SAB_employ_fil %>% 
  filter(gkv.x != gkv.y) #these cases all have source == aokdak, so there seems to be an overlap. however, as the gkv information is not that important, we keep the gkv information from the SAB data
med_fost_diagnoses_SAB_employ_fil <- med_fost_diagnoses_SAB_employ_fil %>% 
  select(-c(gkv.y, REZ_ID, LANR_FAGS, date.medi.presc, PZN_ANZ, DDD1000_PK)) %>%
  rename(gkv = gkv.x) %>%
  ungroup()

#new variable with level 2 ATCs ("therapeutische Untergruppe")
med_fost_diagnoses_SAB_employ_fil <- med_fost_diagnoses_SAB_employ_fil %>% 
  group_by(id_pragma_SAB) %>%
  mutate(Level2_ATC = substr(ATC, 1, 3)) %>%
  ungroup()

#how many different values of Level2_ATC are there? 
unique_level2_ATCs <- unique(med_fost_diagnoses_SAB_employ_fil$Level2_ATC)
length(unique_level2_ATCs) #70

# which level2_ATC is the most frequent?
sorted_atc_counts <- med_fost_diagnoses_SAB_employ_fil %>%
  count(Level2_ATC, sort = TRUE) #Psycholeptika (N05) 

#calculate sum of distinct level 2 ATC codes per SAB
med_fost_diagnoses_SAB_employ_fil <- med_fost_diagnoses_SAB_employ_fil %>%
  group_by(id_pragma_SAB) %>%
  dplyr::summarize(ndistinctATClevel2 = n_distinct(Level2_ATC)) %>%
  ungroup()

table(med_fost_diagnoses_SAB_employ_fil$ndistinctATClevel2)

med_fost_diagnoses_SAB_employ <- left_join(fost_diagnoses_SAB_employ, med_fost_diagnoses_SAB_employ_fil, by = "id_pragma_SAB")

#set NA to 0 
med_fost_diagnoses_SAB_employ <- med_fost_diagnoses_SAB_employ %>%
  mutate(ndistinctATClevel2 = ifelse(is.na(ndistinctATClevel2), 0, ndistinctATClevel2))

summary(med_fost_diagnoses_SAB_employ$ndistinctATClevel2)
hist(med_fost_diagnoses_SAB_employ$ndistinctATClevel2)

```
### Hinzufügen der Qualifizierten Entzugsbehandlung: QEB-ID (Wie viele QEB hat eine Person zum Zeitpunkt des SAB bereits gemacht?)

```{r QEB count}

#Daten zusammenführen

med_fost_diagnoses_SAB_employ_QEB <- bind_rows(
  med_fost_diagnoses_SAB_employ, QEB %>% select(pragmaid, date.treat.start, treatment, date.treat.end))

med_fost_diagnoses_SAB_employ_QEB <- med_fost_diagnoses_SAB_employ_QEB %>%
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(QEB_count_before_SAB = sapply(1:n(), function(i) {
    if (treatment[i] == "SAB") {
      sum(treatment[1:(i-1)] == "QEB" & date.treat.end[1:(i-1)] < date.treat.start[i])
    } else {
      NA
    }
  }))

#check
med_fost_diagnoses_SAB_employ_QEB %>% select(pragmaid, date.treat.start, SAB_id, treatment, QEB_count_before_SAB) %>% arrange(pragmaid, date.treat.start) 

med_fost_diagnoses_SAB_employ_QEB <- med_fost_diagnoses_SAB_employ_QEB %>% filter(treatment == "SAB")

```

## Hinzufügen der REHA ID (wie viele Rehabilitationsbehandlungen hat eine Person zum Zeitpunkt des SAB bereits gemacht?)

```{r reha count}
#Daten zusammenführen

med_fost_diagnoses_SAB_employ_QEB_reha <- bind_rows(
  med_fost_diagnoses_SAB_employ_QEB, reha %>% select(pragmaid, date.treat.start, treatment, date.treat.end))

med_fost_diagnoses_SAB_employ_QEB_reha <- med_fost_diagnoses_SAB_employ_QEB_reha %>%
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(REHA_count_before_SAB = sapply(1:n(), function(i) {
    if (treatment[i] == "SAB") {
      sum(treatment[1:(i-1)] == "reha" & date.treat.end[1:(i-1)] < date.treat.start[i])
    } else {
      NA
    }
  })) %>%
  ungroup()

#check
med_fost_diagnoses_SAB_employ_QEB_reha %>% select(pragmaid, date.treat.start, SAB_id, treatment, QEB_count_before_SAB, REHA_count_before_SAB) %>% arrange(pragmaid, date.treat.start) 

med_fost_diagnoses_SAB_employ_QEB_reha <- med_fost_diagnoses_SAB_employ_QEB_reha %>% filter(treatment == "SAB")
```

## Auswahl relevanter Variablen

```{r select_vars}
final_data <- med_fost_diagnoses_SAB_employ_QEB_reha %>% 
  select(-c(KH_FALL_ID, date.treat.start, date.treat.end, date.emp.start, date.emp.end, id_pragma_SAB, fost.degree, source, died, date.death, yob, treatment))
```

## Zentrieren der kontinuierlichen Variablen

Alle kontinuierlichen Variablen werden zentriert (d. h. der Mittelwert subtrahiert, so dass der Mittelwert = 0 ist). Die Koeffizienten werden dann als die Veränderung der log odds der outcomes bei einer Erhöhung des Prädiktors um eine Einheit interpretiert, wobei alle anderen (kontinuierlichen) Prädiktoren auf ihren Mittelwerten gehalten werden. Der Intercept stellt die log odds des outcomes dar, wenn alle (kontinuierlichen) Prädiktoren auf ihren Mittelwert gesetzt sind.


```{r center}  

variables_to_center <- c("age", "SAB_id", "elix_sum", "ndistinctATClevel2", "QEB_count_before_SAB", "REHA_count_before_SAB", "n.days")

#centering
for (var in variables_to_center) {
  final_data[[paste0(var, "_cent")]] <- scale(final_data[[var]], center = TRUE, scale = FALSE)
}
```

# Interkorrelations Matrix (nur kontinuierliche Variablen)

```{r correlation}
cor_matrix <-  cor(final_data %>% select(c("age_cent", "SAB_id_cent", "elix_sum_cent", "ndistinctATClevel2_cent", "QEB_count_before_SAB_cent", "REHA_count_before_SAB_cent", "n.days_cent")))
cor_matrix
cor_melted <- melt(cor_matrix)

# Heatmap
ggplot(cor_melted, aes(Var1, Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  #add correlation values as text
  geom_text(aes(label = round(value, 2)), vjust = 1) +
  theme_minimal() +
  labs(x = "", y = "", title = "Correlation Heatmap") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


## Speicherplatz freigeben

```{r save_data}
# identify all objects that can be deleted
objects <- ls()
objects <- objects[grepl("all|check|missing|fil", objects)]
#delete all objects that match the pattern
rm(list = objects)
#free unused memory
gc()
```

## Überprüfung der Daten vor Modellierung

### Ausreißer, fehlende Werte und Datentypen

```{r check_data}

final_data$emp.type <- as.factor(final_data$emp.type)
final_data$sex <- as.factor(final_data$sex)
final_data$nationality <- as.factor(final_data$nationality)
final_data$gkv <- as.factor(final_data$gkv)

#check for missings
summary(final_data)
anyNA(final_data) #8 NAs in EmpType -> set to "other"
final_data$emp.type[is.na(final_data$emp.type)] <- "other"

##outliers?
# SAB_id
boxplot(final_data$SAB_id) # some patients had 30 SAB

#elix_sum
boxplot(final_data$elix_sum) 

#ndistinctATClevel2
boxplot(final_data$ndistinctATClevel2) 

#QEB_count_before_SAB
boxplot(final_data$QEB_count_before_SAB)

#REHA_count_before_SAB
boxplot(final_data$REHA_count_before_SAB)
```
### Test der Modellannahme: Linearer Zusammenhang mit Logit des Outcomes

Der Zusammenhang zwischen Prädiktoren und der abhängiggen Variablen irreguläre Beendigung der Behandlung soll mittels logistischen Regressionsmodellen geschätzt werden. Dafür muss zunächst die Modellannahme geprüft werden, dass ein linearer Zusammenhang zwischen metrischen Prädikoren und dem Logit des Outcomes besteht. Um diese Annahme zu testen, werden die logistischen Regressionsmodelle geschätzt und zusätzliche Prädiktoren inkludiert, die die Interkation zwischen dem jeweiligen metrischen Prädiktor und deren Logarithmus darstellen (Hosmer & Lemeshow, 1989).
Relevant ist nur, ob die Interaktionstermine signifikant sind. Jede signifikante Interaktion deutet darauf hin, dass der jeweilige Haupteffekt die Annahme der Linearität im Logit verletzt. 

```{r linearity_test}
# Create the interaction terms of the metric predictors with their logarithm
final_data$logageInt <- log(final_data$age+1) * final_data$age
final_data$logSAB_idInt <- log(final_data$SAB_id+1) * final_data$SAB_id
final_data$logelix_sumInt <- log(final_data$elix_sum+1) * final_data$elix_sum
final_data$logndistinctATClevel2Int <- log(final_data$ndistinctATClevel2+1) * final_data$ndistinctATClevel2
final_data$logQEB_count_before_SABInt <- log(final_data$QEB_count_before_SAB+1) * final_data$QEB_count_before_SAB
final_data$logREHA_count_before_SABInt <- log(final_data$REHA_count_before_SAB+1) * final_data$REHA_count_before_SAB


outcomes <- c("unpl_drop")

predictors <- "sex + nationality + emp.type + age + fost.degree_bin + logageInt + SAB_id + logSAB_idInt + elix_sum + logelix_sumInt + ndistinctATClevel2 + logndistinctATClevel2Int + QEB_count_before_SAB + logQEB_count_before_SABInt + REHA_count_before_SAB + logREHA_count_before_SABInt"

models <- list()

# loop through each outcome and fit the model
for (outcome in outcomes) {
  formula <- as.formula(paste(outcome, "~", predictors))
  models[[outcome]] <- glm(formula, data = final_data, family = binomial(link = "logit"))
  cat("\n\n", outcome, "\n")
  print(summary(models[[outcome]]))
}

```

Es gibt keine signifikanten Interaktionseffekte, die darauf hindeuten, dass die Annahme der Linearität im Logit verletzt ist. Daher wird keine Transformation der Prädiktoren durchgeführt.


### Multikollinearität

```{r multicollinearity}
vif_model <- glm(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent, family = "binomial", data = final_data)

car::vif(vif_model) #no multicollinearity

#"... when using adjusted generalized standard error inflation factor (GSIF = GVIF^(1/(2*Df)), we must take the square-root of our rules of thumb for what is a large value – aGSIF values above √2.5 (1.6) may be of concern, and values above √5 or √10 (2.2 or 3.2) are indicative of a more serious problem"
```

## Anpassung der Logistischen Modelle

```{r log_models}
# initialize a data frame to store model summaries
model_summaries <- data.frame(
  Model = character(),
  Deviance = numeric(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

add_model_summary <- function(model, model_name) {

  model_summaries <<- rbind(model_summaries, data.frame(
    Model = model_name,
    LogLik = logLik(model),
    AIC = AIC(model),
    BIC = BIC(model)
  ))
}

#unconditional model
model1 <- glmmTMB(unpl_drop ~ 1 + (1|pragmaid), family = "binomial", data = final_data) 
summary(model1)
add_model_summary(model1, "Intercept")


model2 <- glmmTMB(unpl_drop ~ sex + (1|pragmaid), family = "binomial", data = final_data)
summary(model2)
add_model_summary(model2, "Model 2")


model3 <- glmmTMB(unpl_drop ~ sex + age_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model3)
add_model_summary(model3, "Model 3")

model4 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model4) 
add_model_summary(model4, "Model 4")

model5 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + (1|pragmaid), family = "binomial", data = final_data)
summary(model5)
add_model_summary(model5, "Model 5")

model6 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + emp.type + (1|pragmaid), family = "binomial", data = final_data)
summary(model6)
add_model_summary(model6, "Model 6")

model7 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model7)
add_model_summary(model7, "Model 7")

model9 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + (1|pragmaid), family = "binomial", data = final_data)
summary(model9)
add_model_summary(model9, "Model 9") 

model10 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model10)
add_model_summary(model10, "Model 10") 

model11 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model11)
add_model_summary(model11, "Model 11") 

model12 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model12)
add_model_summary(model12, "Model 12") 

model13 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + (1|pragmaid), family = "binomial", data = final_data) 
summary(model13)
add_model_summary(model13, "Model 13") 
```

## Hinzunahme der Interaktionen mit SAB_id
```{r interactions}
model14 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent + nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*age_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model14)
add_model_summary(model14, "Model 14")

model15 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*sex + (1|pragmaid), family = "binomial", data = final_data) 
summary(model15)
add_model_summary(model15, "Model 15") 

model16 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*elix_sum_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model16)
add_model_summary(model16, "Model 16") 

model17 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*nationality + (1|pragmaid), family = "binomial", data = final_data) 
summary(model17) 
add_model_summary(model17, "Model 17") 

model_18 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*emp.type + (1|pragmaid), family = "binomial", data = final_data)
summary(model_18) 
add_model_summary(model_18, "Model 18")

model_19 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*fost.degree_bin + (1|pragmaid), family = "binomial", data = final_data)
summary(model_19)
add_model_summary(model_19, "Model 19")

model_20 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*ndistinctATClevel2_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model_20)
add_model_summary(model_20, "Model 20")

model_21 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*QEB_count_before_SAB_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model_21) 
add_model_summary(model_21, "Model 21")

model_22 <- glmmTMB(unpl_drop ~ sex + age_cent + SAB_id_cent+ nationality + emp.type + elix_sum_cent + fost.degree_bin + ndistinctATClevel2_cent + QEB_count_before_SAB_cent + REHA_count_before_SAB_cent + SAB_id_cent*REHA_count_before_SAB_cent + (1|pragmaid), family = "binomial", data = final_data)
summary(model_22) 
add_model_summary(model_22, "Model 22")
```

## Evaluation der Modelle

```{r model_fit}
#find the best fitting model
choose_best_model <- function(summary_df, criterion) {
  if (!criterion %in% names(summary_df)) {
    stop("Ungültiges Kriterium. Wähle entweder 'LogLik', 'AIC' oder 'BIC'.")
  }

  if (criterion == "LogLik") {
    best_model_row <- summary_df[which.max(summary_df[[criterion]]), ]
  } else {
    best_model_row <- summary_df[which.min(summary_df[[criterion]]), ]
  }

  return(best_model_row)
}

choose_best_model(model_summaries, "BIC") 
choose_best_model(model_summaries, "AIC") 
choose_best_model(model_summaries, "LogLik") 

#plot model summaries as skree plot
model_summaries_long <- model_summaries %>%
  pivot_longer(cols = c(LogLik, AIC, BIC), names_to = "Criterion", values_to = "Value")

model_summaries_long$Model <- factor(model_summaries_long$Model, levels = c("Intercept", "Model 2", "Model 3", "Model 4", "Model 5", "Model 6", "Model 7", "Model 8", "Model 9", "Model 10", "Model 11", "Model 12", "Model 13", "Model 14", "Model 15", "Model 16", "Model 17", "Model 18", "Model 19", "Model 20", "Model 21", "Model 22"))

ggplot(model_summaries_long, aes(x = Model, y = Value, color = Criterion)) +
  geom_point(stat = "identity") +
  geom_line(aes(group = Criterion)) +
  facet_wrap(~Criterion, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Model Comparison",
    x = "Model",
    y = "Criterion Value"
  )

```

## Modellauswahl

```{r best_model}
best_model <- model13
```

## Model Diagnostik: ICC and R2
```{r model_iccr2}
#R2 = proportion of the explained variance (of the full model)
performance::r2_nakagawa(best_model) #conditional R2: 21.3%, marginal R2: 4.8%

# ICC = proportion of explained variance that can be attributed to the random effects
residual_var <- pi^2 / 3
random_effects_var <- as.numeric(VarCorr(best_model)$pragmaid[1])
ICC <- random_effects_var / (random_effects_var + residual_var)
print(ICC) #.173
performance::icc(best_model)

# better modelfit than unconditional model?
anova(model1, best_model, test = "Chisq") 
```

## Odds Ratios of significant predictors
```{r odds_ratios}

coefficents <- summary(best_model)$coefficients$cond[, 1]
se <- summary(best_model)$coefficients$cond[, 2]

odds_ratios <- exp(coefficents)

#95% confidence intervals
ci_lower <- exp(coefficents - 1.96 * se)
ci_upper <- exp(coefficents + 1.96 * se)

#combine into a data frame
odds_ratios_df <- data.frame(
  Predictor = names(coefficents),
  OR = odds_ratios,
  CI_lower = ci_lower,
  CI_upper = ci_upper,
  p = summary(best_model)$coefficients$cond[, 4]
)
rownames(odds_ratios_df) <- NULL
```

## Fallzahlen und Stichprobenbeschreibung

```{r sample_size}
# n patients 
n_pat <- final_data %>% distinct(pragmaid) %>% nrow()
print(n_pat)
# n treatments
n_treats <- final_data %>% nrow()
print(n_treats)

#share dropouts
prop.table(table(final_data$unpl_drop))

#AGE
summary(final_data$age)
sd(final_data$age)

#SEX
prop.table(table(final_data$sex))

#emp.type
prop.table(table(final_data$emp.type))

#nationality
prop.table(table(final_data$nationality))

#elix_sum
summary(final_data$elix_sum)

#ndistinctATClevel2
summary(final_data$ndistinctATClevel2)

#fost.degree_bin
prop.table(table(final_data$fost.degree_bin))

#REHA_count_before_SAB
summary(final_data$REHA_count_before_SAB)

#QEB_count_before_SAB
summary(final_data$QEB_count_before_SAB)

#SAB_id
summary(final_data$SAB_id)

#anzahl distinkter pragmaIDs mit SAB_id > 0 / anzahl aller distinkter pragmaIDs = anteil der patienten mit mehr als einer QEB
(final_data %>% filter(SAB_id > 0) %>% distinct(pragmaid) %>% nrow()) / n_pat 
#mehr als 2 QEBs
(final_data %>% filter(SAB_id > 1) %>% distinct(pragmaid) %>% nrow()) / n_pat
#mehr als 3 QEBs
(final_data %>% filter(SAB_id > 2) %>% distinct(pragmaid) %>% nrow()) / n_pat
#mehr als 4 QEBs
(final_data %>% filter(SAB_id > 4) %>% distinct(pragmaid) %>% nrow()) / n_pat

#average number of treatments per patient
#SAB
n_treats_SAB <- final_data %>% group_by(pragmaid) %>% summarise(n_treats = n()) %>% pull(n_treats)
summary(n_treats_SAB)

#REHA
n_treats_reha <- final_data %>%
  group_by(pragmaid) %>%
  slice_max(REHA_count_before_SAB, with_ties = FALSE) %>% 
  ungroup() %>%
  pull(REHA_count_before_SAB)
summary(n_treats_reha)

#QEB
n_treats_QEB <- final_data %>%
  group_by(pragmaid) %>%
  slice_max(QEB_count_before_SAB, with_ties = FALSE) %>% 
  ungroup() %>%
  pull(QEB_count_before_SAB)
summary(n_treats_QEB)

```
# Predicted Probabilities

```{r plot_pred_probs}
# Predicted probabilities
new_labels <- c(
  "(Intercept)" = "Intercept", 
  "age_cent" = "Alter",
  "SAB_id_cent" = "Behandlungserfahrung SAB",
  "sexmale" = "Geschlecht: männlich\n(Ref.: weiblich)",
  "nationalitynicht deutsch" = "Nationalität: deutsch\n(Ref.: nicht-deutsch)",
  "emp.typeother" = "Beschäftigungsstatus: andere\n(Ref.: erwerbstätig)",
  "emp.typeunemployed" = "Beschäftigungsstatus: arbeitslos\n(Ref.: erwerbstätig)",
  "emp.typeretired" = "Beschäftigungsstatus: Rente\n(Ref.: erwerbstätig)",
  "elix_sum_cent" = "Elixhauser-Score",
  "fost.degree_binja" = "Pflegestatus: vorhanden\n(Ref.: nicht vorhanden)",
  "ndistinctATClevel2_cent" = "Anzahl Medikationen",
  "QEB_count_before_SAB_cent" = "Behandlungserfahrung QEB",
  "REHA_count_before_SAB_cent" = "Behandlungserfahrung REHA"
)


coefffix_plot <- sjPlot::plot_model(best_model, vline.color = "black", show.values = TRUE, value.offset = .4, value.size = 3.5, dot.size = 2, sort.est = TRUE, axis.labels = new_labels, title = "", color = c("blue", "red"),  axis.lim = c(0.6, 3), wrap.labels = 100)

coefffix_plot <- coefffix_plot + 
  #change size of axis labels
  theme_minimal() +
  theme(axis.text.y = element_text(size = 12),
        plot.background = element_rect(colour = "black", fill=NA, linewidth = 1)
  )
  
coefffix_plot

#save as svg
ggsave(file.path(folder_plot, "coefffix_plot_SAB.tif"), coefffix_plot, width = 8, height = 5, dpi = 700)
```

# model checking and diagnostics

```{r residuals}

model_simres <- simulateResiduals(best_model)
plot(model_simres)
```
Keine signifikante Abweichung in der Verteilung der Residuen (p-Wert des KS-Tests > 0.05).
Keine Anzeichen von Überdispersion (Dispersionstest nicht signifikant).
Keine Ausreißer (Outlier-Test p = 1).
Visuell zeigen die Residuen keine systematischen Muster.