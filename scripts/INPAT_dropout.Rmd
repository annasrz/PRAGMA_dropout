---
title: "INPAT_dropout"
author: "Anna"
date: "2024-08-07"
output: 
  html_document:
    code_folding: hide
---

# To-Dos
- Outlier Removal?
-   ....

Bei INPAT handelt es sich um stationäre, alkoholbezogene Kontakte (Haupt- oder Fachabteilungsdoiagnose Alkohol), die KEIN qualifizierter Entzug sind. OPS Codes: 9-60x; 9-61x; 9-62x

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
```

# Vorbereitungen

```{r essentials}
# clean workspace
rm(list=ls())
packages <- c("data.table", "tidyverse", "ggplot2", "comorbidity", "car", "glmmTMB", "lme4", "ordinal", "export", "mclogit", "sjPlot", "see", "nnet", "ggeffects", "DHARMa", "effects")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Load packages
invisible(lapply(packages, library, character.only = TRUE))

# current date:
DATE <- format(Sys.Date(), "%Y%m%d")

# themes and options
options(scipen = 999)

# output folders
folder_table <- file.path("..", "output/tables")
folder_plot <- file.path("..", "output/figures")

if (!file.exists(folder_table)) {
  dir.create(folder_table, recursive = TRUE)
}

if (!file.exists(folder_plot)) {
  dir.create(folder_plot, recursive = TRUE)
}
```

# Daten Import

```{r data_import}
print(getwd())
datapath <- file.path("..", "input") 
#read in all RDS-files in datapath 
filenames <- list.files(datapath, pattern = "\\.rds$", full.names = T)

names <- c("pragma_id_GKV", "all_diagnoses", "medications", "employment", "fosterage", "income", "insurance_periods", "inpat_OPS", "inpat", "qwt_OPS", "qwt", "reha", "reha_new")

if (length(filenames) != length(names)) {
  stop("Die Anzahl der Dateien stimmt nicht mit Anzahl names überein.")
}

#save all files as separate dataframes
ldf <- lapply(filenames, readRDS)
names(ldf) <- names[1:length(ldf)]
print(names(ldf))
list2env(ldf, envir = .GlobalEnv) #save all dataframes in global environment as dataframes
```

# Daten vorbereiten

## Daten Struktur
```{r data_structure}
str(inpat)
inpat$n.days <- as.integer(inpat$n.days)

#convert pragmaid to factor in all dataframes
# harmonise column names
#


ldf <- lapply(names(ldf), function(df_name) {
  df <- ldf[[df_name]]
  
  # pragmaid in Faktor umwandeln, falls vorhanden
  if ("pragmaid" %in% colnames(df)) {
    df <- df %>%
      mutate(pragmaid = as.factor(pragmaid))
  }
  
  if (df_name %in% c("reha_new", "reha", "inpat", "qwt")) {
    
    date_columns <- grep("^date\\.(inpat|qwt|drvreha|reha)\\.(start|end)$", colnames(df), value = TRUE)
    
    # Wenn solche Spalten existieren, benenne sie um
    if (length(date_columns) > 0) {
      # Ersetze "date.[irgendwas]" durch "date.treat"
      new_names <- gsub("^date\\..*\\.", "date.treat.", date_columns)
      df <- df %>%
        rename_with(~ new_names, all_of(date_columns))
      
      treatment_types <- gsub("^date\\.(.*)\\..*$", "\\1", date_columns)  # Extrahiere den Mittelteil
      unique_treatments <- unique(treatment_types)
      print(treatment_types)
      df <- df %>%
        mutate(treatment = factor(unique_treatments[1]))  # Füge die Spalte treatment hinzu
    }
  }
  
  return(df)
})

# Überprüfen der Struktur von ldf, um sicherzustellen, dass die Namen korrekt sind
str(ldf)
names(ldf) <- names[1:length(ldf)]

list2env(ldf, envir = .GlobalEnv)
```

## Check Zeiträume

```{r check_immconsec}

## DIREKTE ANSCHLÜSSE
#wenn sich ein treatment direkt an das vorangehende treatment anschließt, sollen beide zusammengefasst werden

inpat <- inpat %>%
  arrange(pragmaid, date.treat.start) %>%
  group_by(pragmaid) %>%
  mutate(
    direkter_anschluss = (date.treat.start == lag(date.treat.end, default = NULL)) | (date.treat.start == lag(date.treat.end, default = NULL) + 1)) #das Startdatum ist gleich dem Enddatum oder es ist um einen Tag versetzt

table(inpat$direkter_anschluss, useNA = "always") #14 with direkter anschluss

#check -> okay
inpat %>% arrange(pragmaid, date.treat.start) %>% filter(direkter_anschluss | lead(direkter_anschluss)) %>% select(pragmaid, date.treat.start, date.treat.end)
```

## Optional: Direkte Anschlüsse zu einem Treatment zusammenfassen

```{r combine_consectreatments}

inpat <- inpat %>% 
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(
    date.treat.start = case_when(
      direkter_anschluss ~ lag(date.treat.start),
      TRUE ~ date.treat.start
    )
  ) %>%
  filter(is.na(lead(direkter_anschluss)) | !lead(direkter_anschluss)) %>%  #Behalte nur diejenigen Zeilen, bei denen `direkter_anschluss` des nächsten Datensatzes FALSE ist
  ungroup()
```

## Any OVERLAPS between treatments within pragmaid?

```{r check_overlaps}

overlap_check <- inpat %>%
  group_by(pragmaid) %>%
  summarize(
    overlap = any(sapply(1:n(), function(i) {
    any(date.treat.start[i] < date.treat.end[-i] & date.treat.end[i] > date.treat.start[-i])
  }))) %>%
  filter(overlap)  

# Anzeigen der Ergebnisse mit Überlappungen
print(overlap_check) # 15 Patienten haben überlappende Behandlungen

inpat$overlap <- FALSE

inpat <- inpat %>%
  group_by(pragmaid) %>%
  mutate(overlap = sapply(1:n(), function(i) {
    any(date.treat.start[i] < date.treat.end[-i] & date.treat.end[i] > date.treat.start[-i])
  }))

table(inpat$overlap, useNA = "always") #45 cases with overlap

# Plot erstellen, um Überlappungen zu visualisieren
ggplot(inpat %>% filter(pragmaid %in% overlap_check$pragmaid), 
       aes(y = pragmaid)) +
  geom_segment(aes(x = date.treat.start, 
                   xend = date.treat.end, 
                   yend = pragmaid, 
                   alpha = as.factor(overlap)),
               size = 5) +
  scale_alpha_manual(values = c(`FALSE` = 0.3, `TRUE` = 1)) +
  labs(x = "Date", y = "Pragma ID") +
  theme_minimal() #some overlaps are not visible, as they are very short (1 day)
```

## Optional: Overlaps in treatments entfernen
```{r remove_overlaps}

cases_to_remove <- inpat %>% 
  filter(overlap == TRUE) %>%
  group_by(pragmaid) %>%
  arrange(pragmaid, date.treat.start) %>%
  mutate(group_overlap = cumsum(
      coalesce(
        as.logical(date.treat.start > lag(date.treat.end, n = 1, default = first(date.treat.start)) &
                   date.treat.start > lag(date.treat.end, n = 2, default = first(date.treat.start)) &
                   date.treat.start > lag(date.treat.end, n = 3, default = first(date.treat.start))
        ), TRUE
      ))) %>%
  group_by(pragmaid, group_overlap) %>%
  mutate(keep = case_when(
    n.days == max(n.days) & row_number() == sample(which(n.days == max(n.days)), 1) ~ "keep",
    n.days == max(n.days) ~ "remove",
    TRUE ~ "remove"
  ))
  
cases_to_remove %>% arrange(pragmaid, date.treat.start) %>% select(pragmaid, date.treat.start, date.treat.end, overlap, group_overlap, keep)

#common columns in cases_to_remove and inpat
common_cols <- intersect(names(cases_to_remove), names(inpat))

sum(cases_to_remove$keep == "remove")

#inpat: remove cases with keep == "remove" in cases_to_remove
inpat <- inpat %>% 
  left_join(cases_to_remove, by = common_cols) %>%
  filter(is.na(keep) | keep == "keep") %>%
  select(-c(overlap, group_overlap, keep, direkter_anschluss))

```

## Outcome Variablen Definition?

### ENTLASS301

```{r recode_ENTL}
labels_entl301 <- c(
  "1" = "regulär",
  "2" = "beendet, nachstat. Beh. vorgesehen",
  "3" = "aus sonstigen Gründen beendet",
  "4" = "gegen ärztlichen Rat beendet",
  "6" = "Verlegung in ein anderes Krankenhaus",
  "7" = "Tod",
  "9" = "Rehaeinrichtung",
  "10" = "Pflegeeinrichtung",
  "14" = "aus sonst. Gründen beend., nachstat. Beh. Vorges.",
  "15" = "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.",
  "17" = "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG",
  "22" = "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."
)

inpat$ENTL301 <- factor(inpat$ENTL301, levels = names(labels_entl301), labels = labels_entl301)

#Einteilung der ENTLASS Gründe in "ungeplant abgebrochen" vs "regulär beendet bzw. nicht ungeplant abgebrochen" (wenig sensitiv, aber spezifisch, dh wahrscheinlich werden viele Fälle verpasst, die ungeplant abgebrochen haben, aber dafür wenig falsch positive, dh hohe spezifität)
inpat <- inpat %>% 
  filter(ENTL301 != "Tod") %>%
  mutate(unpl_drop = factor(case_when(
  ENTL301 %in% c("aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.") ~ 1,
  ENTL301 %in% c("regulär", "beendet, nachstat. Beh. vorgesehen", "Verlegung in ein anderes Krankenhaus", "Rehaeinrichtung", "Pflegeeinrichtung",
                 "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh.") ~ 0,
  TRUE ~ NA_real_), levels = c(0, 1), labels = c("nein", "ja")))

table(inpat$ENTL301, useNA = "always")
table(inpat$unpl_drop, useNA = "ifany")

prop.table(table(inpat$unpl_drop, useNA = "ifany"))
ggplot(inpat, aes(x = unpl_drop, y = n.days)) + geom_violin() + geom_boxplot(width = 0.1) + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + ylim(NA, 75)

#Fallzahl
inpat %>% filter(ENTL301 != "Tod") %>% summarise(n = n(), npragmaid = n_distinct(pragmaid))

```

### Validierung der ENTLASS301 Variable an Behandlungsdauer

```{r check_ENTL301}
#prop.table(table(inpat$ENTL301))

#ggplot(inpat, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

#add Anzahl Tage in Behandlung
#qwt <- qwt %>% 
#  mutate(n.days = as.integer(difftime(as.Date(date.qwt.end), as.Date(date.qwt.start), units = "days")) + 1)


#summary(qwt$n.days)
#summary(inpat$n.days)
#IQR(qwt$n.days)
#IQR(inpat$n.days)
#check outliers
#boxplot(qwt$n.days)
#boxplot(inpat$n.days) #sehr viele Ausreißer, Maximum 365 Tage

# bind datasets for plotting purposes
#inpat$dataset <- "inpat"
#qwt$dataset <- "qwt"

#qwt_inpat <- bind_rows(
#  inpat %>% select(ENTL301, n.days, dataset),
#  qwt %>% select(ENTL301, n.days, dataset)
#)


#ggplot(qwt_inpat, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1)) + facet_wrap(~dataset)
#INPAT hat größeren Anteil "gegen ärztlichen Rat beendet" und "aus sonstigen Gründen beendet" verglichen mit QWT

#ggplot(qwt_inpat %>% filter(ENTL301 != "Tod"), aes(x = dataset, y = n.days)) +
#  geom_jitter(alpha=0.2, size = rel(0.8), height = 0.2) +
#  geom_violinhalf(width = 0.3, outlier.shape = NA) +
#  geom_boxplot(width = 0.05, outlier.shape = NA) +
#  scale_y_continuous(limits = c(0, 60), breaks = seq(0, 60, by = 5))


#treatdur_ETNL_qwt_inpat <- ggplot(qwt_inpat %>% filter(ENTL301 != "Tod"), aes(x = ENTL301, y = n.days)) + 
#  geom_jitter(alpha = 0.1, size = rel(0.65)) +
#  geom_boxplot(width = 0.34, outlier.shape = NA, alpha = 0.7) +
#  facet_grid(dataset ~ .) +
#  scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 10)) +
  #change y axis label
#  ylab("Anzahl Tage in QE") +
#  xlab("Entlassungsgrund (ENTL301)") +
  #change legend title
#  labs(title = "Dauer einer Behandlung nach Entlassungsgrund und Treatment unter GKV Versicherten") +
#  theme_minimal() +
#  theme(axis.text.x = element_text(angle = 35, hjust = 1, size = rel(0.85)))

#save plot to doc
#graph2doc(x = treatdur_ETNL_qwt_inpat, file=file.path(folder_plot, "treatdur_ETNL_qwt_inpat.png"), width=10, height=7)
```

Die Variable ENTL301 gibt den Entlassungsgrund an. Die meisten Behandlungen werden regulär beendet, wobei auffällig ist, dass es unter diesen viele Behandlungen gibt, die nur wenige Tage dauern. Es gibt eine dern QWT Behandlungen ähnliche, aber nicht ganz so stark ausgepärgte zweigipfelige Verteilung der Behandlungsdauer bei den regulär beendeten Behandlungen mit einem Peak um eine Woche und 21 Tage. Die ENTL301-Variable wird trotz dieser Inkonsistenzen verwendet, um einen ungeplanten Dropout zu operationalisieren.

Als alternative Operationalisierung der AV Behandlungserfolg des Aufenthalts stattdessen (wie mit den QWT Daten) die Anzahl der Tage in Behandlung heranzuziehen, macht hier nicht so viel Sinn, weil die Varianz sehr groß ist und es kaum extrerne Validierung gibt und die inhaltliche Bedeutung unklar ist. Dementsprechend müssen wir auf die ENTL301 zurückgreifen. 

# Prädiktoren

## Validierung inpat_id

```{r check_qwt_id}
# does the inpat_id increases with increasing date.treat.start?
inpat_check <- inpat %>% 
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(inpat_id_ordered = row_number()) %>%
  select(pragmaid, inpat_id, inpat_id_ordered, date.treat.start, date.treat.end) #inpat_id was unordered before. therefore, replace inpat_id with inpat_id_ordered

#correct inpat_id, so that it is ordered by date.treat.start
inpat <- inpat %>% 
  group_by(pragmaid) %>%
#  filter(ENTL301 != "Tod") %>% #exclude cases with ENTL301 == Tod)
  arrange(date.treat.start) %>%
  mutate(inpat_id = row_number()) %>%
  mutate(treat_dur_cat = factor(case_when(
  #more than or 20 days in treatment
  n.days >= 21 ~ 3,
  #between 7 and 19 days (inclusive)
  n.days >= 7 & n.days < 21 ~ 2,
  #between 0 and 6 days (inclusive)
  n.days >= 0 & n.days < 7 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("1-6 Tage","7-20 Tage", "21+ Tage")))

```

## Hinzufügen der Stammdaten - SEX + AGE + NATIONALITY

```{r add_stammdaten}
#match pragma_id_GKV with inpat based on pragma_id to get sex and age information 
total_stamm <- left_join(inpat, pragma_id_GKV, by="pragmaid")

table(total_stamm$gkv.x, useNA = "always")
table(total_stamm$gkv.y, useNA = "always") # 7 cases that are insured by both AOK and DAK (this information is not needed for the analysis, so keep only the insurence information from gkv.x)

total_stamm <- total_stamm %>% 
  select(c(-hivid, -gkv.id, -dak.id, -aok.id, - gkv.y)) %>%
  mutate(age = as.integer(substr(date.treat.start, 1, 4)) - yob) %>% #calculate age at the beginning of the inpatient treatment
  rename(gkv = gkv.x) #rename gkv.x to gkv

table(total_stamm$sex, useNA = "always") # 0 NAs
summary(total_stamm$age) # 0 NAs
```

## Hinzufügen Emplyoment Status

```{r add_employment}
nrow(distinct(total_stamm, pragmaid, inpat_id)) #3833 Fälle bzw 3885 Fälle (je nach Ausschluss von overlapping bzw. direkten Anschlüssen)
employ_unfiltered <- left_join(total_stamm, employment, by = "pragmaid")

table(employ_unfiltered$gkv.x, useNA = "always")
table(employ_unfiltered$gkv.y, useNA = "always") #same

employ_unfiltered <- employ_unfiltered %>% 
  select(- gkv.y) %>%
  rename(gkv = gkv.x) #rename gkv.x to gkv

inpat_employ <- employ_unfiltered %>%
  filter(date.treat.start >= date.emp.start & date.treat.start <= date.emp.end)

nrow(distinct(inpat_employ, pragmaid, inpat_id))
nrow(inpat_employ) - nrow(total_stamm) # there are 30 cases less than before - why?

missing_rows <- total_stamm %>%
  anti_join(inpat_employ, by = c("pragmaid", "inpat_id"))

employment %>% filter(pragmaid %in% missing_rows$pragmaid) %>% group_by(pragmaid) # no employment data for the inpat duration of these cases - why? 
```

### Sind fehlende Daten für Employment auf Unterbrechungen in Versichertenzeiten zurückzuführen?

```{r check_missing_employment}
#check if missing employment data is due to interruptions in insured periods
check_missing <- left_join(missing_rows, insurance_periods, by = c("pragmaid")) %>%
  select(pragmaid, date.treat.start, date.treat.end, date.ins.start, date.ins.end, gkv.x) 

#filter cases where the inpat treatment is covered by insurance
cases_with_valid_ins <- check_missing %>% filter(date.treat.start >= date.ins.start & date.treat.start <= date.ins.end) #there are 8 cases that do have insurance data for the inpatient treatment, but have no corresponding employment data. these cases should be kept in the inpat_employ dataset, as they are insured during the inpatient treatment and the employment status should be set to NA.

# -> some, but not all cases with missing employment data are due to interruptions in insured periods

#add cases with valid insurance to inpat_employ
inpat_employ <- bind_rows(inpat_employ, total_stamm %>% filter(pragmaid %in% cases_with_valid_ins$pragmaid & date.treat.start %in% cases_with_valid_ins$date.treat.start))

table(inpat_employ$emp.type, useNA = "always") # 8 NAs, so the 8 cases without employment infos, but with insurance are added to the inpat_employ dataset
```

## Hinzufügen von Diagnose-Daten

```{r add_diagnoses}
sum(is.na(all_diagnoses$pragmaid)) #158 -> why?

table(all_diagnoses$icd_type)

# keep only diagnoses of patients in inpat_employ, with icd_type confirmed, primary, secondary, any and that are not alcohol related
diagnoses_inpat <- all_diagnoses %>% 
  filter(pragmaid %in% inpat_employ$pragmaid) %>% #keep only rows that are in inpat data 
  filter(icd_type %in% c("confirmed", "primary", "secondary", "any")) %>%
  filter(icd.alc == FALSE) %>%#keep only diaignoses that are not alcohol related (as all inpat cases are alcohol related)
  mutate(length_diag = as.integer(difftime(as.Date(date.diag.end), as.Date(date.diag.start), units = "days"))) 

#check
nrow(distinct(inpat_employ, pragmaid)) - nrow(distinct(diagnoses_inpat, pragmaid)) # 2 patients do not have any diagnoses that matches the criteria

summary(diagnoses_inpat$length_diag)

#plot histogram of length_diag
ggplot(diagnoses_inpat, aes(x = length_diag)) + geom_histogram(binwidth = 1) +
  facet_wrap(~setting, scales = "free_y") +
  scale_x_continuous(limits = c(0, 100))

#show cases with NA in length_diag
diagnoses_inpat %>% 
  filter(is.na(date.diag.start)) %>%
  select(pragmaid, icd, icd_type, setting, date.diag.start, date.diag.end)

#delete length_diag
diagnoses_inpat <- select(diagnoses_inpat, -length_diag)

# if date.diag.start is NA, set it to date.diag.end
diagnoses_inpat <- diagnoses_inpat %>% 
  mutate(date.diag.start = dplyr::if_else(is.na(date.diag.start), date.diag.end, date.diag.start))

# join diagnoses with inpat_employ
diagnoses_inpat_employ_alltimes <- left_join(inpat_employ, diagnoses_inpat, by = c("pragmaid")) 

#check
nrow(distinct(diagnoses_inpat_employ_alltimes, pragmaid, inpat_id)) #3865 -> okay ( originally 3887 cases - 22 cases without valid insurance)

# keep only diagnoses in the timeframe of interest (maximum 2 quarters before inpat start)
diagnoses_inpat_employ_fil <- diagnoses_inpat_employ_alltimes %>%
  filter(
    #Ambulante Diagnosen (Dauer: 1 Quartal) dürfen nicht später zurückliegend als 2 Quartale vor QWT-Start gestellt worden sein und maximal gleich QWT-Start liegen
     date.diag.start >= (date.treat.start - days(180)) & date.diag.start <= date.treat.start)
#Arbeitsdefinition, evtl für stationäre Diagnosen (bzw. alle anderen settings) Eingrenzung anpassen?

sum(diagnoses_inpat_employ_fil$gkv.x != diagnoses_inpat_employ_fil$gkv.y) # 33 cases where the insurance information is not the same in the diagnoses data and the inpat data

diagnoses_inpat_employ_fil %>% filter(gkv.x != gkv.y) #these cases all have source == aokdak, so there seems to be an overlap. however, as the gkv information is not that important, we keep the gkv information from the inpat data

diagnoses_inpat_employ_fil <- diagnoses_inpat_employ_fil %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

nrow(distinct(diagnoses_inpat_employ_fil, pragmaid, inpat_id)) #3842 (before 3865 - 23 cases were excluded as they did not have a diagnosis in the timeframe of interest - they will be added in the end again


# Charlson and Elixhauser Comorbidity Index

diagnoses_inpat_employ_fil$id_pragma_inpat <- paste(diagnoses_inpat_employ_fil$pragmaid, diagnoses_inpat_employ_fil$inpat_id, sep = "_")

comorb_elix <- comorbidity::comorbidity(x=diagnoses_inpat_employ_fil, id = "id_pragma_inpat",
                                code = "icd",map="elixhauser_icd10_quan",
                                assign0 = T, tidy.codes = T)
print(head(comorb_elix))  
comorb_char <- comorbidity::comorbidity(x=diagnoses_inpat_employ_fil, id = "id_pragma_inpat",
                                code = "icd",map="charlson_icd10_quan",
                                assign0 = T,tidy.codes = T)
print(head(comorb_char))  

comorb_elix_sum <- comorb_elix %>%
  #new column with row sums using all columns except id_pragma_inpat
  mutate(elix_sum = rowSums(select(., -id_pragma_inpat))) %>%
  select(id_pragma_inpat, elix_sum)

comorb_char_sum <- comorb_char %>%
  #new column with row sums using all columns except id_pragma_inpat
  mutate(char_sum = rowSums(select(., -id_pragma_inpat))) %>%
  select(id_pragma_inpat, char_sum)

#bind both comorbidity dataframes
comorb_sum <- left_join(comorb_elix_sum, comorb_char_sum, by = "id_pragma_inpat")
print(head(comorb_sum))      

nrow(distinct(inpat_employ, pragmaid, inpat_id)) - nrow(distinct(comorb_sum, id_pragma_inpat)) #23 cases, these have to be added to the comorb_sum dataset 

inpat_employ$id_pragma_inpat <- paste(inpat_employ$pragmaid, inpat_employ$inpat_id, sep = "_")

diagnoses_inpat_employ <- left_join(inpat_employ, comorb_sum, by = "id_pragma_inpat")

#are there missings? 
nrow(inpat_employ) - nrow(diagnoses_inpat_employ) #0
sum(is.na(diagnoses_inpat_employ$elix_sum)) #23 missings
sum(is.na(diagnoses_inpat_employ$char_sum)) #23 missings

#set NAs to 0
diagnoses_inpat_employ <- diagnoses_inpat_employ %>% 
  mutate(elix_sum = replace_na(elix_sum, 0),
         char_sum = replace_na(char_sum, 0))
```

### Diagnose Daten Descriptives

```{r check_ndiagnoses}
#plot histogram of number of diagnoses
ggplot(diagnoses_inpat_employ, aes(x = elix_sum)) + geom_histogram(binwidth = 1)
summary(diagnoses_inpat_employ$elix_sum)
ggplot(diagnoses_inpat_employ, aes(x = char_sum)) + geom_histogram(binwidth = 1)
summary(diagnoses_inpat_employ$char_sum) 
```

## Hinzufügen von Pflegegraden

```{r add_pflegegrad}
table(fosterage$fost.degree, useNA = "always")
# sowohl Pflegegrade (PG) als auch Pflegestufen (PS). Pflegegrade sind ab 2017 gültig, Pflegestufen bis 2016. Wie Pflegestufen in Pflegegrade umrechnen?

fost_inpat <- fosterage %>% 
  filter(pragmaid %in% diagnoses_inpat_employ$pragmaid)

#checks
sum(is.na(fost_inpat$pragmaid)) #0
sum(is.na(fost_inpat$date.fost.start)) #0
nrow(distinct(diagnoses_inpat_employ, pragmaid)) - nrow(distinct(fost_inpat, pragmaid)) #1523 patients do not have fosterage data, 257 have


fost_diagnoses_inpat_employ_alltimes <- left_join(diagnoses_inpat_employ, fost_inpat, by = "pragmaid")


fost_diagnoses_inpat_employ_fil <- fost_diagnoses_inpat_employ_alltimes %>%
  filter((date.treat.start >= date.fost.start & is.na(date.fost.end)) | (date.treat.start >= date.fost.start & date.treat.start <= date.fost.end))

nrow(distinct(fost_diagnoses_inpat_employ_fil, pragmaid)) # 139 patients do have a pflegegrad/stufe during the beginning of the inpatient treatment

# GKV X - GKV Y
sum(fost_diagnoses_inpat_employ_fil$gkv.x != fost_diagnoses_inpat_employ_fil$gkv.y) # 0 cases where the insurance information is not the same in the fosterage data and the inpat data
fost_diagnoses_inpat_employ_fil <- fost_diagnoses_inpat_employ_fil %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x) %>% 
  ungroup()

#add fosterage data to diagnoses_inpat_employ and set fosterage to NA if there is no fosterage data
fost_diagnoses_inpat_employ <- diagnoses_inpat_employ %>% 
  left_join(fost_diagnoses_inpat_employ_fil %>% select(id_pragma_inpat, fost.degree), by = "id_pragma_inpat") %>%
  mutate(fost.degree_bin = as.factor(ifelse(is.na(fost.degree), "nein", "ja"))) 

table(fost_diagnoses_inpat_employ$fost.degree_bin, useNA = "always") #253 cases with fosterage degree-> okay

```

## Hinzufügen von Medikation

```{r add_medication}
med_inpat <- medications %>% 
  filter(pragmaid %in% fost_diagnoses_inpat_employ$pragmaid)

#checks
sum(is.na(med_inpat$pragmaid)) #0
sum(is.na(med_inpat$date.med.start)) #0
nrow(distinct(fost_diagnoses_inpat_employ, pragmaid)) - nrow(distinct(med_inpat, pragmaid)) #59 patients do not have medication data, 1721 have

med_fost_diagnoses_inpat_employ_alltimes <- left_join(fost_diagnoses_inpat_employ, med_inpat, by = "pragmaid")
nrow(distinct(med_fost_diagnoses_inpat_employ_alltimes, pragmaid)) # 1780 -> okay

med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_alltimes %>%
  # only keep medication data that happend during the 3 months before the inpatient treatment
  filter(date.medi.disp >= (date.treat.start - days(30)) & date.medi.disp <= date.treat.start) %>%
  filter(ATC != "")

nrow(distinct(med_fost_diagnoses_inpat_employ_fil, id_pragma_inpat)) # 1513 inpatient treatments have medication data in the timeframe of interest

#GKV X - GKV Y
sum(med_fost_diagnoses_inpat_employ_fil$gkv.x != med_fost_diagnoses_inpat_employ_fil$gkv.y) # 2 cases where the insurance information is not the same in the medication data and the inpat data
med_fost_diagnoses_inpat_employ_fil %>% 
  filter(gkv.x != gkv.y) #these cases all have source == aokdak, so there seems to be an overlap. however, as the gkv information is not that important, we keep the gkv information from the inpat data
med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_fil %>% 
  select(-c(gkv.y, REZ_ID, LANR_FAGS, date.medi.presc, PZN_ANZ, DDD1000_PK)) %>%
  rename(gkv = gkv.x) %>%
  ungroup()

#new variable with level 2 ATCs (therapeutische Untergruppe)
med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_fil %>% 
  group_by(id_pragma_inpat) %>%
  mutate(Level2_ATC = substr(ATC, 1, 3)) %>%
  ungroup()

#how many different values of Level2_ATC are there? 
unique_level2_ATCs <- unique(med_fost_diagnoses_inpat_employ_fil$Level2_ATC)
length(unique_level2_ATCs) #70

# welche Untergruppe ist am häufigsten vertreten?
sorted_atc_counts <- med_fost_diagnoses_inpat_employ_fil %>%
  count(Level2_ATC, sort = TRUE) #Psycholeptika (N05) kommt am häufigsten vor

#calculate sum of disting full ATC and level 2 ATC codes
med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_fil %>%
  group_by(id_pragma_inpat) %>%
  dplyr::summarize(ndistinctATClevel2 = n_distinct(Level2_ATC), 
            ndistinctATC = n_distinct(ATC)) %>%
  ungroup()

table(med_fost_diagnoses_inpat_employ_fil$ndistinctATClevel2)

med_fost_diagnoses_inpat_employ <- left_join(fost_diagnoses_inpat_employ, med_fost_diagnoses_inpat_employ_fil, by = "id_pragma_inpat")

med_fost_diagnoses_inpat_employ <- med_fost_diagnoses_inpat_employ %>%
  mutate(ndistinctATC = ifelse(is.na(ndistinctATC), 0, ndistinctATC)) %>%
  mutate(ndistinctATClevel2 = ifelse(is.na(ndistinctATClevel2), 0, ndistinctATClevel2)) %>%
  mutate(polymedi = as.factor(ifelse(ndistinctATC >= 6, "ja", "nein"))) %>%
  mutate(polymedi_level2 = as.factor(ifelse(ndistinctATClevel2 >= 5, "ja", "nein")))

summary(med_fost_diagnoses_inpat_employ$ndistinctATClevel2)
hist(med_fost_diagnoses_inpat_employ$ndistinctATClevel2)

```
## Hinzufügen von QWT ID (wie viele QWTs hat eine Person zum Zeitpunkt des INPAT treatments bereits gemacht?)

```{r qwt count}

#Daten zusammenführen

med_fost_diagnoses_inpat_employ_qwt <- bind_rows(
  med_fost_diagnoses_inpat_employ, qwt %>% select(pragmaid, date.treat.start, treatment, date.treat.end))

med_fost_diagnoses_inpat_employ_qwt <- med_fost_diagnoses_inpat_employ_qwt %>%
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(QWT_count_before_INPAT = sapply(1:n(), function(i) {
    if (treatment[i] == "inpat") {
      sum(treatment[1:(i-1)] == "qwt" & date.treat.end[1:(i-1)] < date.treat.start[i])
    } else {
      NA
    }
  }))

#check
med_fost_diagnoses_inpat_employ_qwt %>% select(pragmaid, date.treat.start, inpat_id, treatment, QWT_count_before_INPAT) %>% arrange(pragmaid, date.treat.start) #okay

med_fost_diagnoses_inpat_employ_qwt <- med_fost_diagnoses_inpat_employ_qwt %>% filter(treatment == "inpat")

```

## Hinzufügen von REHA ID (wie viele Rehas hat eine Person zum Zeitpunkt des INPAT treatments bereits gemacht?)

```{r reha count}
#Daten zusammenführen (mit reha statt der reha_new Daten, da in den reha daten sowohl GKV als auch DRV vorhanden sind)

med_fost_diagnoses_inpat_employ_qwt_reha <- bind_rows(
  med_fost_diagnoses_inpat_employ_qwt, reha %>% select(pragmaid, date.treat.start, treatment, date.treat.end))

med_fost_diagnoses_inpat_employ_qwt_reha <- med_fost_diagnoses_inpat_employ_qwt_reha %>%
  group_by(pragmaid) %>%
  arrange(date.treat.start) %>%
  mutate(REHA_count_before_INPAT = sapply(1:n(), function(i) {
    if (treatment[i] == "inpat") {
      sum(treatment[1:(i-1)] == "reha" & date.treat.end[1:(i-1)] < date.treat.start[i])
    } else {
      NA
    }
  }))

#check
med_fost_diagnoses_inpat_employ_qwt_reha %>% select(pragmaid, date.treat.start, inpat_id, treatment, QWT_count_before_INPAT, REHA_count_before_INPAT) %>% arrange(pragmaid, date.treat.start) #okay

med_fost_diagnoses_inpat_employ_qwt_reha <- med_fost_diagnoses_inpat_employ_qwt_reha %>% filter(treatment == "inpat")

```

# Auswahl relevanter Variablen

```{r select_vars}
final_data <- med_fost_diagnoses_inpat_employ_qwt_reha %>% 
  select(-c(KH_FALL_ID, date.treat.start, date.treat.end, date.emp.start, date.emp.end, id_pragma_inpat, fost.degree, source, died, date.death, yob, treatment))
```

# Speicherplatz freigeben

```{r save_data}
#alle Datenfiles die "all" oder "check" oder "missing" im Namen haben, können gelöscht werden
#identifiziere alle Objekte, die gelöscht werden können
objects <- ls()
objects <- objects[grepl("all|check|missing|fil", objects)]
#lösche alle Objekte
rm(list = objects)
#free unused memory
gc()
```

# Überprüfung der Daten vor Modellierung

## Ausreißer, fehlende Werte und Datentypen

```{r check_data}

final_data$emp.type <- as.factor(final_data$emp.type)
final_data$sex <- as.factor(final_data$sex)
final_data$nationality <- as.factor(final_data$nationality)
final_data$gkv <- as.factor(final_data$gkv)

#check for missings
summary(final_data)
anyNA(final_data) #8 NAs in EmpType -> set to "other"
final_data$emp.type[is.na(final_data$emp.type)] <- "other"

##outliers?
## remove #all outliers that match the definition: bigger than 75% quantile + 3*IQR (Tukey's fences)

# inpat_id
boxplot(final_data$inpat_id) # some patients did 30 treatments -> remove them?
#cutoff_inpatid <- quantile(final_data$inpat_id, 0.75) + 3*IQR(final_data$inpat_id)
#cutoff_inpatid
#remove them
#final_data <- final_data %>% filter(inpat_id <= cutoff_inpatid)

# ndays
boxplot(final_data$n.days)# many outliers
cutoff <- quantile(final_data$n.days, 0.75) + 3*IQR(final_data$n.days)
#final_data <- final_data %>% filter(n.days <= cutoff)

# char_sum
boxplot(final_data$char_sum) # some outliers
cutoff_char <- quantile(final_data$char_sum, 0.75) + 3*IQR(final_data$char_sum)
cutoff_char
#final_data <- final_data %>% filter(char_sum <= cutoff_char)

#elix_sum
boxplot(final_data$elix_sum) # some outliers
cuttoff_elix <- quantile(final_data$elix_sum, 0.75) + 3*IQR(final_data$elix_sum)
cuttoff_elix
#final_data <- final_data %>% filter(elix_sum <= cuttoff_elix)

#ndistinctATClevel2
boxplot(final_data$ndistinctATClevel2) # some outliers
cutoff_ndistinctATClevel2 <- quantile(final_data$ndistinctATClevel2, 0.75) + 3*IQR(final_data$ndistinctATClevel2)
cutoff_ndistinctATClevel2
#final_data <- final_data %>% filter(ndistinctATClevel2 <= cutoff_ndistinctATClevel2)

#QWT_count_before_INPAT
boxplot(final_data$QWT_count_before_INPAT)
cutoff_QWT_count_before_INPAT <- quantile(final_data$QWT_count_before_INPAT, 0.75) + 3*IQR(final_data$QWT_count_before_INPAT)
cutoff_QWT_count_before_INPAT
```

## Standardizing variables

Convert variables which do not have a meaningful zero point to z-scores (i.e. mean = 0, sd = 1). Coefficients are then interpreted as the change in the log odds of the outcome for a one standard deviation change in the predictor and the intercept is the log odds of the outcome when all predictors are zero (= in case of standardized variables, the mean of the variable).

# not up to date: elix_sum, ndistinctATClevel2, QWT_count_before_INPAT, REHA_count_before_INPAT are not standardized, as they do have a meaningful zero point.

```{r standardize}  
#age
final_data$age_std <- scale(final_data$age, center = TRUE, scale = TRUE)

#inpat_id
final_data$inpat_id_std <- scale(final_data$inpat_id, center = TRUE, scale = TRUE)

#n.days
final_data$n.days_std <- scale(final_data$n.days, center = TRUE, scale = TRUE)

#elix_sum
final_data$elix_sum_std <- scale(final_data$elix_sum, center = TRUE, scale = TRUE)

#QWT_count_before_INPAT
final_data$QWT_count_before_INPAT_std <- scale(final_data$QWT_count_before_INPAT, center = TRUE, scale = TRUE)

#REHA_count_before_INPAT
final_data$REHA_count_before_INPAT_std <- scale(final_data$REHA_count_before_INPAT, center = TRUE, scale = TRUE)

#ndistinctATClevel2
final_data$ndistinctATClevel2_std <- scale(final_data$ndistinctATClevel2, center = TRUE, scale = TRUE)

#char_sum
final_data$char_sum_std <- scale(final_data$char_sum, center = TRUE, scale = TRUE)
```


## Multicollinearity

```{r multicollinearity}
vif_model <- glm(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + QWT_count_before_INPAT_std + REHA_count_before_INPAT_std, family = "binomial", data = final_data)

car::vif(vif_model) #no multicollinearity

#"A consequence is that when using adjusted adjusted generalized standard error inflation factor (GSIF = GVIF^(1/(2*Df)), we must take the square-root of our rules of thumb for what is a large value – aGSIF values above √2.5 (1.6) may be of concern, and values above √5 or √10 (2.2 or 3.2) are indicative of a more serious problem"

#correlation matrix
#raq_poly <- psych::polychoric(items)
#raq_cor <- raq_poly$rho
#round(raq_cor, 2)
#psych::cor.plot(raq_cor, upper = FALSE)

```

#Logistische Modelle

```{r log_models}
# Initialisiere einen leeren DataFrame für die Modellanpassungsparameter
model_summaries <- data.frame(
  Model = character(),
  Deviance = numeric(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

add_model_summary <- function(model, model_name) {
#  summary <- summary(model)
#  stats <- summary$sumstat
  model_summaries <<- rbind(model_summaries, data.frame(
    Model = model_name,
    LogLik = logLik(model),
    AIC = AIC(model),
    BIC = BIC(model)
  ))
}

#nur Intercept und random effects
model1 <- glmmTMB(unpl_drop ~ 1 + (1|pragmaid), family = "binomial", data = final_data)
summary(model1)
add_model_summary(model1, "Intercept")


model2 <- glmmTMB(unpl_drop ~ sex + (1|pragmaid), family = "binomial", data = final_data) #model 2 führt zu Verbesserungen
summary(model2)
add_model_summary(model2, "Model 2")


model3 <- glmmTMB(unpl_drop ~ sex + age_std + (1|pragmaid), family = "binomial", data = final_data)
summary(model3)
add_model_summary(model3, "Model 3")

model4 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + (1|pragmaid), family = "binomial", data = final_data)
summary(model4) # Modell 4 bietet keinen Vorteil gegenüber Modell 3 -> INPAT ID rauslassen?
add_model_summary(model4, "Model 4")

model5 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + (1|pragmaid), family = "binomial", data = final_data)
summary(model5) # Modell 5 bietet keinen Vorteil gegenüber Modell 3 (außer leicht niedrigerer deviance)
add_model_summary(model5, "Model 5")


model6 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + (1|pragmaid), family = "binomial", data = final_data)
summary(model6) # Model 6 hat besseres AIC und deviance als Modell 3, aber schlechteres BIC
add_model_summary(model6, "Model 6")

model7 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std+ nationality + emp.type + elix_sum_std + (1|pragmaid), family = "binomial", data = final_data)
summary(model7)
add_model_summary(model7, "Model 7")


# ist char_sum ein besserer Prädiktor?
model8 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + char_sum_std + (1|pragmaid), family = "binomial", data = final_data)
summary(model8)
add_model_summary(model8, "Model 8") # char_sum passt schlechter als elix_sum_std, ist aber auch signifikant

model9 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + elix_sum_std + fost.degree_bin + (1|pragmaid), family = "binomial", data = final_data)
summary(model9)
add_model_summary(model9, "Model 9") # keine Verbesserung gegenüber Modell 8

model10 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + (1|pragmaid), family = "binomial", data = final_data)
summary(model10)
add_model_summary(model10, "Model 10") 

model11 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + (1|pragmaid), family = "binomial", data = final_data)
summary(model11)
add_model_summary(model11, "Model 11") 


model12 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + QWT_count_before_INPAT_std + (1|pragmaid), family = "binomial", data = final_data)
summary(model12)
add_model_summary(model12, "Model 12") 

model13 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std+ nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + QWT_count_before_INPAT_std + REHA_count_before_INPAT_std + (1|pragmaid), family = "binomial", data = final_data) #Hinzunahme von REHA_count_before_INPAT_std ist nicht signifikant und verschlechtert model fit (auch wenn Reihenfolge umgekehr, dh wenn erst REHA count und dann QWT count aufgenommen wird)
summary(model13)
add_model_summary(model13, "Model 13") 

model14 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std + nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + QWT_count_before_INPAT_std + REHA_count_before_INPAT_std + inpat_id_std*age_std + (1|pragmaid), family = "binomial", data = final_data) #Hinzunahme von Interaktion inpat_id*age_std verbessert AIC und LogLik leicht, Interaktion ist signifikant
summary(model14)
add_model_summary(model14, "Model 14") 

model15 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std+ nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + QWT_count_before_INPAT_std + REHA_count_before_INPAT_std + inpat_id_std*age_std + inpat_id_std*sex + (1|pragmaid), family = "binomial", data = final_data) 
#Interaktion inpat_id_std*sex ist nicht signifikant

summary(model15)
add_model_summary(model15, "Model 15") 
#Ist Modelverbesserung signifikant durch Hinzunahme von inpat_id_std*sex?
d14 <- as.numeric(-2*logLik(model14)) #is the -2LL for mod0
d15 <- as.numeric(-2*logLik(model15)) #is the -2LL for mod2
ldif <- d14 - d15 #is the -2LL difference
degfr <- 1 #difference in the number of parameters. degfr is 1 because mod15 has one extra parameter
##compute the p-value.
pchisq(ldif, degfr, lower.tail = FALSE) #.13
#the -2LL of Model15 is not significantly closer to 0

Anova(model12)
Anova(model12,type="III") # to do: set sum-to-zero contrasts on factors and center numerical covariates

model16 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std+ nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + QWT_count_before_INPAT_std + REHA_count_before_INPAT_std + inpat_id_std*age_std + inpat_id_std*elix_sum_std + (1|pragmaid), family = "binomial", data = final_data)
summary(model16) #Hinzunahme von Interaktion inpat_id_std*elix*sum verbessert modelfit nicht
add_model_summary(model16, "Model 16") 


model17 <- glmmTMB(unpl_drop ~ sex + age_std + inpat_id_std+ nationality + emp.type + elix_sum_std + fost.degree_bin + ndistinctATClevel2_std + treat_dur_cat + QWT_count_before_INPAT_std + REHA_count_before_INPAT_std + inpat_id_std*age_std + sex*age_std + (1|pragmaid), family = "binomial", data = final_data) #Hinzunahme von Interaktion inpat_id_std*age_std verbessert AIC und LogLik leicht, Interaktion ist signifikant
summary(model17) #Hinzunahme von Interaktion sex*age_std verbessert modelfit nicht
add_model_summary(model17, "Model 17") 


#Interpretation: Bei einer geringen Anzahl von Behandlungen (niedrige inpat_id_std) nimmt die Wahrscheinlichkeit eines Abbruchs stärker mit dem Alter ab. Bei einer höheren Anzahl von Behandlungen ist der Einfluss des Alters weniger stark.

#find the best fitting model
choose_best_model <- function(summary_df, criterion) {
  if (!criterion %in% names(summary_df)) {
    stop("Ungültiges Kriterium. Wähle entweder 'LogLik', 'AIC' oder 'BIC'.")
  }

  if (criterion == "LogLik") {
    best_model_row <- summary_df[which.max(summary_df[[criterion]]), ]
  } else {
    best_model_row <- summary_df[which.min(summary_df[[criterion]]), ]
  }

  return(best_model_row)
}

choose_best_model(model_summaries, "BIC") 
choose_best_model(model_summaries, "AIC") 
choose_best_model(model_summaries, "LogLik") 

```

# Predicted Probabilities

```{r plot_pred_probs}
# Predicted probabilities
# Erstelle ein neues Datenset, durch das die interessierenden Variablen variiert werden

coefffix_plot <- sjPlot::plot_model(model14, vline.color = "black", show.values = TRUE, value.offset = .4, value.size = 3, dot.size = 2, sort.est = TRUE)

plot(ggpredict(model14, terms = c("age_std", "inpat_id_std")))

#graph2doc(x = coefffix_plot, file=file.path(folder_plot, "coefffix_plot_inpat.png"), width=7, height=5)

#effekte der prädiktoren unter konstanthaltung aller anderen prädiktoren
ae <- allEffects(model14)
plot(ae)

plot(ae["age_std:inpat_id_std"])
plot(ae["sex"])
plot(ae["elix_sum_std"])
plot(ae["treat_dur_cat"])
plot(ae["REHA_count_before_INPAT_std"])
```

# model checking and diagnostics

```{r residuals}

model_simres <- simulateResiduals(model14)
plot(model_simres)
```
Keine signifikante Abweichung in der Verteilung der Residuen (p-Wert des KS-Tests > 0.05).
Keine Anzeichen von Überdispersion (Dispersionstest nicht signifikant).
Keine Ausreißer (Outlier-Test p = 1).
Visuell zeigen die Residuen keine systematischen Muster.

```{r check_linearity}

# ASSUMPTIONS:
#Linearity: Linear relationship between continuous variables and the logit transformation of the outcome variable. 

probabilities <- predict(model8, type = "response")
#dataset with only continuous variables
final_data_cont <- final_data %>% ungroup() %>% select_if(is.numeric) %>% select(-(c(treat_dur_cat_num, n.days, ndistinctATC, elix_sum)))

predictors <- colnames(final_data_cont)


# Logit für jede Kategorie berechnen 
logits <- apply(probabilities, 2, function(p) log(p / (1 - p)))

logits_df <- as.data.frame(logits) 
combined_data <- cbind(final_data_cont, logits_df)

final_data_long <- combined_data %>%
  pivot_longer(
    cols = all_of(names(logits_df)),  # Nutze die Spaltennamen deiner logits_df direkt
    names_to = "category",
    values_to = "logit"
  ) %>%
  pivot_longer(
    cols = all_of(predictors),   # Stelle sicher, dass predictors existiert
    names_to = "predictors",
    values_to = "predictor.value"
  )

# Scatterplot
ckeck_lin <- ggplot(final_data_long, aes(x = predictor.value, y = logit)) +
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") +
  theme_bw() +
  facet_grid(category ~ predictors, scales = "free") +
  labs(
    title = "Beziehung zwischen Prädiktoren und Logits",
    x = "Prädiktorwert",
    y = "Logit"
  ) +
    theme(
    strip.text = element_text(size = 6)  # Verkleinert die Textgröße für Facettenbeschriftungen
  )

ggsave("check_linearity.png", ckeck_lin, width = 20, height = 25, units = "cm")

#looks mostly fine, but maybe some problems with elix_sum (plot for 7-20 days), looks rather cubic than linear
```




# OLD:
```{r OLD}
#nur Intercept und random effects
model1 <- mblogit(formula = treat_dur_cat ~ 1, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model1)
add_model_summary(model1, "Intercept")

glmmTMB(unpl_drop ~ sex + age + qwt_id + nationality + emp.type + elix_sum + fost.degree_bin + polymedi + (1|pragmaid), data = final_data, family = binomial)



model2 <- mblogit(formula = treat_dur_cat ~ sex, random = ~ 1 | pragmaid, data = final_data) #model 2 führt zu keiner Verbesserungen (lediglich etwas geringere deviance)
getSummary.mblogit(model2)
add_model_summary(model2, "Model 2")


model3 <- mblogit(formula = treat_dur_cat ~ sex + age, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model3) #Modell 3 hat die besten Anpassungswerte basierend auf Devianz, AIC und BIC. "age" scheint ein signifikanter Prädiktor für die Kategorien „7–20 Tage“ und „21+ Tage“ im Vergleich zu „1-6 Tage“ zu sein.
add_model_summary(model3, "Model 3")

model4 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model4) # Modell 4 bietet keinen Vorteil gegenüber Modell 3
add_model_summary(model4, "Model 4")

model5 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + nationality, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model5) # Modell 5 bietet keinen Vorteil gegenüber Modell 3 (außer leicht niedrigerer deviance), nationality wird nicht in das modell aufgenommen
add_model_summary(model5, "Model 5")


model6 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model6) # Model 6 hat besseres AIC und deviance als Modell 3, aber schlechteres BIC
add_model_summary(model6, "Model 6")

model7 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + gkv, random = ~ 1 | pragmaid, data = final_data) # Model 7 bietet keinen Vorteil gegenüber Modell 6
getSummary.mblogit(model7)
add_model_summary(model7, "Model 7")


model8 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + elix_sum, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model8) 
add_model_summary(model8, "Model 8") # elix_sum als wichtiger Prädiktor

# ist char_sum ein besserer Prädiktor?
model9 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + char_sum, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model9)
add_model_summary(model9, "Model 9") # char_sum passt schlechter als elix_sum, ist aber auch signifikant

model10 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + elix_sum + fost.degree_bin, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model10)
add_model_summary(model10, "Model 10") # keine Verbesserung gegenüber Modell 8

model11 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + elix_sum + ndistinctATClevel2, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model11)
add_model_summary(model11, "Model 11") 

#find the best fitting model
choose_best_model <- function(summary_df, criterion) {
  if (!criterion %in% names(summary_df)) {
    stop("Ungültiges Kriterium. Wähle entweder 'Deviance', 'AIC' oder 'BIC'.")
  }
  best_model_row <- summary_df[which.min(summary_df[[criterion]]), ]
  return(best_model_row)
}

choose_best_model(model_summaries, "BIC") #Model 1 (Intercept) hat den besten fit
choose_best_model(model_summaries, "AIC") #Model 8 hat den besten fit
choose_best_model(model_summaries, "Deviance") #Model 11 hat den besten fit

``` 
### Behandlungsdauer als AV

```{r create vars}
#qwt_inpat <- qwt_inpat %>%
#  mutate(treat_dur_cat = factor(case_when(
#  #more than or 21 days in treatment
#  n.days >= 21 ~ 3,
#  #between 7 and 20 days (inclusive)
#  n.days >= 7 & n.days < 21 ~ 2,
#  #between 0 and 6 days (inclusive)
#  n.days >= 0 & n.days < 7 ~ 1,
#  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("1-6 Tage","7-20 Tage", "21+ Tage")))

#check distribution
#ggplot(qwt_inpat, aes(x = treat_dur_cat)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1)) + facet_wrap(~dataset)

```

