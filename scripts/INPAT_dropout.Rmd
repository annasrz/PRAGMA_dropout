---
title: "INPAT_dropout"
author: "Anna"
date: "2024-08-07"
output: 
  html_document:
    code_folding: hide
---
# To-Dos

- ....


Bei INPAT handelt es sich um stationäre, alkoholbezogene Kontakte (Haupt- oder Fachabteilungsdoiagnose Alkohol), die KEIN qualifizierter Entzug sind. OPS Codes: 9-60x; 9-61x; 9-62x
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
```
# Vorbereitungen

```{r essentials}
# clean workspace
rm(list=ls())
packages <- c("data.table", "tidyverse", "ggplot2", "comorbidity", "car", "lme4", "ordinal", "export", "mclogit", "sjPlot", "see", "nnet")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Load packages
invisible(lapply(packages, library, character.only = TRUE))

# current date:
DATE <- format(Sys.Date(), "%Y%m%d")

# themes and options
options(scipen = 999)

# output folders
folder_table <- file.path("..", "output/tables")
folder_plot <- file.path("..", "output/figures")

if (!file.exists(folder_table)) {
  dir.create(folder_table, recursive = TRUE)
}

if (!file.exists(folder_plot)) {
  dir.create(folder_plot, recursive = TRUE)
}
```

# Daten Import

```{r data_import}
print(getwd())
datapath <- file.path("..", "input") 
#read in all files in datapath 
filenames <- list.files(datapath, pattern = "\\.rds$", full.names = T)

#save all files as separate dataframes
ldf <- lapply(filenames, readRDS)
names(ldf) <- gsub(".rds", "", basename(filenames))
print(names(ldf))
names <- c("pragma_id_GKV", "alc_diagnoses", "all_diagnoses", "medications", "employment", "fosterage", "income", "insurance_periods", "inpat_OPS", "inpat", "qwt_OPS", "qwt", "reha")
names(ldf) <- names
#check if all dataframes are loaded
ls()
list2env(ldf, envir = .GlobalEnv) #save all dataframes in global environment as dataframes
rm(ldf)
```
# Daten vorbereiten

## Outcome Variablen Definition? 

### ENTLASS301
```{r recode_ENTL}
table(inpat$ENTL301)

#inpat as factor with new labels
inpat$ENTL301 <- factor(inpat$ENTL301, levels = c(1, 2, 3, 4, 6, 7, 9, 10, 13, 14, 15, 17, 22), labels = c("regulär", "beendet, nachstat. Beh. vorgesehen", "aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "Verlegung in ein anderes Krankenhaus", "Tod", "Rehaeinrichtung",
"Pflegeeinrichtung", "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."))
#was passiert nach interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG?

#same for qwt
table(qwt$ENTL301)
qwt$ENTL301 <- factor(qwt$ENTL301, levels = c(1, 2, 3, 4, 6, 7, 9, 10, 13, 14, 15, 17, 22), labels = c("regulär", "beendet, nachstat. Beh. vorgesehen", "aus sonstigen Gründen beendet", "gegen ärztlichen Rat beendet", "Verlegung in ein anderes Krankenhaus", "Tod", "Rehaeinrichtung",
"Pflegeeinrichtung", "externe Verlegung zur psychiatrischen Behandlung", "aus sonst. Gründen beend., nachstat. Beh. Vorges.", "gegen ärztlichen Rat beendet, nachstat. Beh. vorgeseh.", "interne Verlegung m. Wechsel zw. D. Gelt.b. BPflV u. KHEntgG", "Fallabschl. (int. V.) b. Wechsel zw. Voll- und teilst. Beh."))

```
### Validierung der ENTLASS301 Variable an Behandlungsdauer

```{r check_ENTL301}
prop.table(table(inpat$ENTL301))
prop.table(table(qwt$ENTL301))

ggplot(inpat, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1))

#add Anzahl Tage in Behandlung
qwt <- qwt %>% 
  mutate(n.days = as.integer(difftime(as.Date(date.qwt.end), as.Date(date.qwt.start), units = "days")) + 1)

inpat$n.days <- as.numeric(inpat$n.days)


summary(qwt$n.days)
summary(inpat$n.days)
IQR(qwt$n.days)
IQR(inpat$n.days)
#check outliers
boxplot(qwt$n.days)
boxplot(inpat$n.days) #sehr viele Ausreißer, Maximum 365 Tage
inpat_wooutliers <- inpat %>% filter(n.days < quantile(n.days, 0.75) + 3*IQR(n.days))
#how many cases are removed?
nrow(inpat) - nrow(inpat_wooutliers) #78 cases with ndays more than 3 IQRs away from the median
#show cases with n.days > 3 IQRs

# bind datasets for plotting purposes
inpat$dataset <- "inpat"
qwt$dataset <- "qwt"

qwt_inpat <- bind_rows(
  inpat %>% select(ENTL301, n.days, dataset),
  qwt %>% select(ENTL301, n.days, dataset)
)


ggplot(qwt_inpat, aes(x = ENTL301)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1)) + facet_wrap(~dataset)
#INPAT hat größeren Anteil "gegen ärztlichen Rat beendet" und "aus sonstigen Gründen beendet" verglichen mit QWT

ggplot(qwt_inpat %>% filter(ENTL301 != "Tod"), aes(x = dataset, y = n.days)) +
  geom_jitter(alpha=0.2, size = rel(0.8), height = 0.2) +
  geom_violinhalf(width = 0.3, outlier.shape = NA) +
  geom_boxplot(width = 0.05, outlier.shape = NA) +
  scale_y_continuous(limits = c(0, 60), breaks = seq(0, 60, by = 5))


ggplot(qwt_inpat %>% filter(ENTL301 != "Tod"), aes(x = ENTL301, y = n.days)) + 
  geom_jitter(alpha = 0.1, size = rel(0.65)) +
  geom_boxplot(width = 0.34, outlier.shape = NA, alpha = 0.7) +
  facet_grid(dataset ~ .) +
  scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 10)) +
  #change y axis label
  ylab("Anzahl Tage in QE") +
  xlab("Entlassungsgrund (ENTL301)") +
  #change legend title
  labs(title = "Dauer eines Qualifizierten Entzugs nach Entlassungsgrund unter GKV Versicherten", caption = "Anmerk.: Datenpunkte markieren einzelne Behandlungen") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 35, hjust = 1, size = rel(0.85)))
```
Die Variable ENTL301 gibt den Entlassungsgrund an. Die meisten Behandlungen werden regulär beendet, wobei auffällig ist, dass es unter diesen viele Behandlungen gibt, die nur wenige Tage dauern. Es gibt eine ähnliche, aber nicht ganz so stark ausgepärgte zweigipfelige Verteilung der Behandlungsdauer bei den regulär beendeten Behandlungen mit einem Peak um eine Woche und 21 Tage. Die ENTL301-Variable scheint daher (wieder) nicht ideal um einen Dropout bzw. einen erfolgreichen Behandlungsabschluss zu operationalisieren.

Als alternative Operationalisierung der AV Behandlungserfolg des Aufenthalts ziehen wir daher stattdessen (wie mit den QWT Daten) die Anzahl der Tage in Behandlung heran. Die Behandlungsdauer teilen wir in drei Gruppen ein: 0-6 Tage, 7-20 Tage, und 21+ Tage. Dies entspricht einigermaßen der empirischen Verteilung, wobei die inhaltliche Bedeutung unklar ist. 


### Behandlungsdauer als AV
```{r create vars}
qwt_inpat <- qwt_inpat %>%
  mutate(treat_dur_cat = factor(case_when(
  #more than or 20 days in treatment
  n.days >= 21 ~ 3,
  #between 7 and 19 days (inclusive)
  n.days >= 7 & n.days < 21 ~ 2,
  #between 0 and 6 days (inclusive)
  n.days >= 0 & n.days < 7 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("1-6 Tage","7-20 Tage", "21+ Tage")))

#check distribution
ggplot(qwt_inpat, aes(x = treat_dur_cat)) + geom_bar() + theme(axis.text.x = element_text(angle = 25, hjust = 1)) + facet_wrap(~dataset)

```
# Prädiktoren

## Validierung qwt_id
```{r check_qwt_id}
# does the inpat_id increases with increasing date.inpat.start?
inpat_check <- inpat %>% 
  group_by(pragmaid) %>%
  arrange(date.inpat.start) %>%
  mutate(inpat_id_ordered = row_number()) %>%
  select(pragmaid, inpat_id, inpat_id_ordered, date.inpat.start, date.inpat.end) #inpat_id was unordered before. therefore, replace inpat_id with inpat_id_ordered

#correct inpat_id, so that it is ordered by date.inpat.start
inpat <- inpat %>% 
  group_by(pragmaid) %>%
  arrange(date.inpat.start) %>%
  mutate(inpat_id = row_number()) %>%
  mutate(treat_dur_cat = factor(case_when(
  #more than or 20 days in treatment
  n.days >= 21 ~ 3,
  #between 7 and 19 days (inclusive)
  n.days >= 7 & n.days < 21 ~ 2,
  #between 0 and 6 days (inclusive)
  n.days >= 0 & n.days < 7 ~ 1,
  TRUE ~ NA_real_), levels = c(1, 2, 3), labels = c("1-6 Tage","7-20 Tage", "21+ Tage")))
```

## Hinzufügen der Stammdaten - SEX + AGE + NATIONALITY
```{r add_stammdaten}
#match pragma_id_GKV with inpat based on pragma_id to get sex and age information 
total_stamm <- left_join(inpat, pragma_id_GKV, by="pragmaid")


table(total_stamm$gkv.x, useNA = "always")
table(total_stamm$gkv.y, useNA = "always") # 7 cases that are insured by both AOK and DAK (this information is not needed for the analysis, so keep only the insurence information from gkv.x)

total_stamm <- total_stamm %>% 
  select(c(-hivid, -gkv.id, -dak.id, -aok.id, - gkv.y)) %>%
  mutate(age = as.integer(substr(date.inpat.start, 1, 4)) - yob) %>% #calculate age at the beginning of the inpatient treatment
  rename(gkv = gkv.x) #rename gkv.x to gkv

total_stamm$pragmaid <- factor(total_stamm$pragmaid)

table(total_stamm$sex, useNA = "always") # 0 NAs
summary(total_stamm$age) # 0 NAs
```

## Hinzufügen Emplyoment Status
```{r add_employment}
nrow(distinct(total_stamm, pragmaid, inpat_id)) #3887 Fälle
employ_unfiltered <- left_join(total_stamm, employment, by = "pragmaid")
nrow(distinct(total_stamm, pragmaid, inpat_id)) # 3887 cases

table(employ_unfiltered$gkv.x, useNA = "always")
table(employ_unfiltered$gkv.y, useNA = "always") #same

employ_unfiltered <- employ_unfiltered %>% 
  select(- gkv.y) %>%
  rename(gkv = gkv.x) #rename gkv.x to gkv

inpat_employ <- employ_unfiltered %>%
  filter(date.inpat.start >= date.emp.start & date.inpat.start <= date.emp.end)

nrow(distinct(inpat_employ, pragmaid, inpat_id))
nrow(inpat_employ) - nrow(total_stamm) # there are 30 cases less than before - why?

missing_rows <- total_stamm %>%
  anti_join(inpat_employ, by = c("pragmaid", "inpat_id"))

employment %>% filter(pragmaid %in% missing_rows$pragmaid) %>% group_by(pragmaid) # no employment data for the inpat duration of these cases - why? 
```

### Sind fehlende Daten für Employment auf Unterbrechungen in Versichertenzeiten zurückzuführen?
```{r check_missing_employment}
#check if missing employment data is due to interruptions in insured periods
check_missing <- left_join(missing_rows, insurance_periods, by = c("pragmaid")) %>%
  select(pragmaid, date.inpat.start, date.inpat.end, date.ins.start, date.ins.end, gkv.x) 

#filter cases where the inpat treatment is covered by insurance
cases_with_valid_ins <- check_missing %>% filter(date.inpat.start >= date.ins.start & date.inpat.start <= date.ins.end) #there are 8 cases that do have insurance data for the inpatient treatment, but have no corresponding employment data. these cases should be kept in the inpat_employ dataset, as they are insured during the inpatient treatment and the employment status should be set to NA.

# -> some, but not all cases with missing employment data are due to interruptions in insured periods

#add cases with valid insurance to inpat_employ
inpat_employ <- bind_rows(inpat_employ, total_stamm %>% filter(pragmaid %in% cases_with_valid_ins$pragmaid & date.inpat.start %in% cases_with_valid_ins$date.inpat.start))

table(inpat_employ$emp.type, useNA = "always") # 8 NAs, so the 8 cases without employment infos, but with insurance are added to the inpat_employ dataset
``` 
## Hinzufügen von Diagnose-Daten

```{r add_diagnoses}
sum(is.na(all_diagnoses$pragmaid)) #158 -> why?

table(all_diagnoses$icd_type)

# keep only diagnoses of patients in inpat_employ, with icd_type confirmed, primary, secondary, any and that are not alcohol related
diagnoses_inpat <- all_diagnoses %>% 
  filter(pragmaid %in% inpat_employ$pragmaid) %>% #keep only rows that are in inpat data 
  filter(icd_type %in% c("confirmed", "primary", "secondary", "any")) %>%
  filter(icd.alc == FALSE) %>%#keep only diaignoses that are not alcohol related (as all inpat cases are alcohol related)
  mutate(length_diag = as.integer(difftime(as.Date(date.diag.end), as.Date(date.diag.start), units = "days"))) 

#check
nrow(distinct(inpat_employ, pragmaid)) - nrow(distinct(diagnoses_inpat, pragmaid)) # 2 patients do not have any diagnoses that matches the criteria

summary(diagnoses_inpat$length_diag)

#plot histogram of length_diag
ggplot(diagnoses_inpat, aes(x = length_diag)) + geom_histogram(binwidth = 1) +
  facet_wrap(~setting, scales = "free_y") +
  scale_x_continuous(limits = c(0, 100))

#show cases with NA in length_diag
diagnoses_inpat %>% 
  filter(is.na(date.diag.start)) %>%
  select(pragmaid, icd, icd_type, setting, date.diag.start, date.diag.end)

#delete length_diag
diagnoses_inpat <- select(diagnoses_inpat, -length_diag)

# if date.diag.start is NA, set it to date.diag.end
diagnoses_inpat <- diagnoses_inpat %>% 
  mutate(date.diag.start = dplyr::if_else(is.na(date.diag.start), date.diag.end, date.diag.start))

# join diagnoses with inpat_employ
diagnoses_inpat_employ_alltimes <- left_join(inpat_employ, diagnoses_inpat, by = c("pragmaid")) 

#check
nrow(distinct(diagnoses_inpat_employ_alltimes, pragmaid, inpat_id)) #3865 -> okay ( originally 3887 cases - 22 cases without valid insurance)

# keep only diagnoses in the timeframe of interest (maximum 2 quarters before inpat start)
diagnoses_inpat_employ_fil <- diagnoses_inpat_employ_alltimes %>%
  filter(
    #Ambulante Diagnosen (Dauer: 1 Quartal) dürfen nicht später zurückliegend als 2 Quartale vor QWT-Start gestellt worden sein und maximal gleich QWT-Start liegen
     date.diag.start >= (date.inpat.start - days(180)) & date.diag.start <= date.inpat.start)
#Arbeitsdefinition, evtl für stationäre Diagnosen (bzw. alle anderen settings) Eingrenzung anpassen?

sum(diagnoses_inpat_employ_fil$gkv.x != diagnoses_inpat_employ_fil$gkv.y) # 33 cases where the insurance information is not the same in the diagnoses data and the inpat data

diagnoses_inpat_employ_fil %>% filter(gkv.x != gkv.y) #these cases all have source == aokdak, so there seems to be an overlap. however, as the gkv information is not that important, we keep the gkv information from the inpat data

diagnoses_inpat_employ_fil <- diagnoses_inpat_employ_fil %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x)

nrow(distinct(diagnoses_inpat_employ_fil, pragmaid, inpat_id)) #3842 (before 3865 - 23 cases were excluded as they did not have a diagnosis in the timeframe of interest - they will be added in the end again


# Charlson and Elixhauser Comorbidity Index

diagnoses_inpat_employ_fil$id_pragma_inpat <- paste(diagnoses_inpat_employ_fil$pragmaid, diagnoses_inpat_employ_fil$inpat_id, sep = "_")

comorb_elix <- comorbidity::comorbidity(x=diagnoses_inpat_employ_fil, id = "id_pragma_inpat",
                                code = "icd",map="elixhauser_icd10_quan",
                                assign0 = T, tidy.codes = T)
print(head(comorb_elix))  
comorb_char <- comorbidity::comorbidity(x=diagnoses_inpat_employ_fil, id = "id_pragma_inpat",
                                code = "icd",map="charlson_icd10_quan",
                                assign0 = T,tidy.codes = T)
print(head(comorb_char))  

comorb_elix_sum <- comorb_elix %>%
  #new column with row sums using all columns except id_pragma_inpat
  mutate(elix_sum = rowSums(select(., -id_pragma_inpat))) %>%
  select(id_pragma_inpat, elix_sum)

comorb_char_sum <- comorb_char %>%
  #new column with row sums using all columns except id_pragma_inpat
  mutate(char_sum = rowSums(select(., -id_pragma_inpat))) %>%
  select(id_pragma_inpat, char_sum)

#bind both comorbidity dataframes
comorb_sum <- left_join(comorb_elix_sum, comorb_char_sum, by = "id_pragma_inpat")
print(head(comorb_sum))      

nrow(distinct(inpat_employ, pragmaid, inpat_id)) - nrow(distinct(comorb_sum, id_pragma_inpat)) #23 cases, these have to be added to the comorb_sum dataset 

inpat_employ$id_pragma_inpat <- paste(inpat_employ$pragmaid, inpat_employ$inpat_id, sep = "_")

diagnoses_inpat_employ <- left_join(inpat_employ, comorb_sum, by = "id_pragma_inpat")

#are there missings? 
nrow(inpat_employ) - nrow(diagnoses_inpat_employ) #0
sum(is.na(diagnoses_inpat_employ$elix_sum)) #23 missings
sum(is.na(diagnoses_inpat_employ$char_sum)) #23 missings

#set NAs to 0
diagnoses_inpat_employ <- diagnoses_inpat_employ %>% 
  mutate(elix_sum = replace_na(elix_sum, 0),
         char_sum = replace_na(char_sum, 0))
```

### Diagnose Daten Descriptives 
```{r check_ndiagnoses}
#plot histogram of number of diagnoses
ggplot(diagnoses_inpat_employ, aes(x = elix_sum)) + geom_histogram(binwidth = 1)
summary(diagnoses_inpat_employ$elix_sum)
ggplot(diagnoses_inpat_employ, aes(x = char_sum)) + geom_histogram(binwidth = 1)
summary(diagnoses_inpat_employ$char_sum) 
```
## Hinzufügen von Pflegegraden
```{r add_pflegegrad}
table(fosterage$fost.degree, useNA = "always")
# sowohl Pflegegrade (PG) als auch Pflegestufen (PS). Pflegegrade sind ab 2017 gültig, Pflegestufen bis 2016. Wie Pflegestufen in Pflegegrade umrechnen?

fost_inpat <- fosterage %>% 
  filter(pragmaid %in% diagnoses_inpat_employ$pragmaid)

#checks
sum(is.na(fost_inpat$pragmaid)) #0
sum(is.na(fost_inpat$date.fost.start)) #0
nrow(distinct(diagnoses_inpat_employ, pragmaid)) - nrow(distinct(fost_inpat, pragmaid)) #1523 patients do not have fosterage data, 257 have


fost_diagnoses_inpat_employ_alltimes <- left_join(diagnoses_inpat_employ, fost_inpat, by = "pragmaid")


fost_diagnoses_inpat_employ_fil <- fost_diagnoses_inpat_employ_alltimes %>%
  filter((date.inpat.start >= date.fost.start & is.na(date.fost.end)) | (date.inpat.start >= date.fost.start & date.inpat.start <= date.fost.end))

nrow(distinct(fost_diagnoses_inpat_employ_fil, pragmaid)) # 139 patients do have a pflegegrad/stufe during the beginning of the inpatient treatment

# GKV X - GKV Y
sum(fost_diagnoses_inpat_employ_fil$gkv.x != fost_diagnoses_inpat_employ_fil$gkv.y) # 0 cases where the insurance information is not the same in the fosterage data and the inpat data
fost_diagnoses_inpat_employ_fil <- fost_diagnoses_inpat_employ_fil %>% 
  select(-gkv.y) %>%
  rename(gkv = gkv.x) %>% 
  ungroup()

#add fosterage data to diagnoses_inpat_employ and set fosterage to NA if there is no fosterage data
fost_diagnoses_inpat_employ <- diagnoses_inpat_employ %>% 
  left_join(fost_diagnoses_inpat_employ_fil %>% select(id_pragma_inpat, fost.degree), by = "id_pragma_inpat") %>%
  mutate(fost.degree_bin = as.factor(ifelse(is.na(fost.degree), "nein", "ja"))) 

table(fost_diagnoses_inpat_employ$fost.degree_bin, useNA = "always") #253 cases with fosterage degree-> okay

```

## Hinzufügen von Medikation

```{r add_medication}
med_inpat <- medications %>% 
  filter(pragmaid %in% fost_diagnoses_inpat_employ$pragmaid)

#checks
sum(is.na(med_inpat$pragmaid)) #0
sum(is.na(med_inpat$date.med.start)) #0
nrow(distinct(fost_diagnoses_inpat_employ, pragmaid)) - nrow(distinct(med_inpat, pragmaid)) #59 patients do not have medication data, 1721 have

med_fost_diagnoses_inpat_employ_alltimes <- left_join(fost_diagnoses_inpat_employ, med_inpat, by = "pragmaid")
nrow(distinct(med_fost_diagnoses_inpat_employ_alltimes, pragmaid)) # 1780 -> okay

med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_alltimes %>%
  # only keep medication data that happend during the 3 months before the inpatient treatment
  filter(date.medi.disp >= (date.inpat.start - days(30)) & date.medi.disp <= date.inpat.start) %>%
  filter(ATC != "")

nrow(distinct(med_fost_diagnoses_inpat_employ_fil, id_pragma_inpat)) # 1513 inpatient treatments have medication data in the timeframe of interest

#GKV X - GKV Y
sum(med_fost_diagnoses_inpat_employ_fil$gkv.x != med_fost_diagnoses_inpat_employ_fil$gkv.y) # 2 cases where the insurance information is not the same in the medication data and the inpat data
med_fost_diagnoses_inpat_employ_fil %>% 
  filter(gkv.x != gkv.y) #these cases all have source == aokdak, so there seems to be an overlap. however, as the gkv information is not that important, we keep the gkv information from the inpat data
med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_fil %>% 
  select(-c(gkv.y, REZ_ID, LANR_FAGS, date.medi.presc, PZN_ANZ, DDD1000_PK)) %>%
  rename(gkv = gkv.x) %>%
  ungroup()

#new variable with level 2 ATCs (therapeutische Untergruppe)
med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_fil %>% 
  group_by(id_pragma_inpat) %>%
  mutate(Level2_ATC = substr(ATC, 1, 3)) %>%
  ungroup()

#how many different values of Level2_ATC are there? 
unique_level2_ATCs <- unique(med_fost_diagnoses_inpat_employ_fil$Level2_ATC)
length(unique_level2_ATCs) #70

# welche Untergruppe ist am häufigsten vertreten?
sorted_atc_counts <- med_fost_diagnoses_inpat_employ_fil %>%
  count(Level2_ATC, sort = TRUE) #Psycholeptika (N05) kommt am häufigsten vor

#calculate sum of disting full ATC and level 2 ATC codes
med_fost_diagnoses_inpat_employ_fil <- med_fost_diagnoses_inpat_employ_fil %>%
  group_by(id_pragma_inpat) %>%
  dplyr::summarize(ndistinctATClevel2 = n_distinct(Level2_ATC), 
            ndistinctATC = n_distinct(ATC)) %>%
  ungroup()

table(med_fost_diagnoses_inpat_employ_fil$ndistinctATClevel2)

med_fost_diagnoses_inpat_employ <- left_join(fost_diagnoses_inpat_employ, med_fost_diagnoses_inpat_employ_fil, by = "id_pragma_inpat")

med_fost_diagnoses_inpat_employ <- med_fost_diagnoses_inpat_employ %>%
  mutate(ndistinctATC = ifelse(is.na(ndistinctATC), 0, ndistinctATC)) %>%
  mutate(ndistinctATClevel2 = ifelse(is.na(ndistinctATClevel2), 0, ndistinctATClevel2)) %>%
  mutate(polymedi = as.factor(ifelse(ndistinctATC >= 6, "ja", "nein"))) %>%
  mutate(polymedi_level2 = as.factor(ifelse(ndistinctATClevel2 >= 5, "ja", "nein")))

summary(med_fost_diagnoses_inpat_employ$ndistinctATClevel2)
hist(med_fost_diagnoses_inpat_employ$ndistinctATClevel2)

```

# Auswahl relevanter Variablen
```{r select_vars}
final_data <- med_fost_diagnoses_inpat_employ %>% 
  select(-c(KH_FALL_ID, date.inpat.start, date.inpat.end, dataset, date.emp.start, date.emp.end, id_pragma_inpat, fost.degree, source, died, date.death, yob))
```

# Speicherplatz freigeben
```{r save_data}
#alle Datenfiles die "all" oder "check" oder "missing" im Namen haben, können gelöscht werden
#identifiziere alle Objekte, die gelöscht werden können
objects <- ls()
objects <- objects[grepl("all|check|missing|fil", objects)]
#lösche alle Objekte
rm(list = objects)
#free unused memory
gc()
```

# Überprüfung der Daten vor Modellierung
```{r check_data}

final_data$emp.type <- as.factor(final_data$emp.type)
final_data$sex <- as.factor(final_data$sex)
final_data$nationality <- as.factor(final_data$nationality)
final_data$gkv <- as.factor(final_data$gkv)
final_data$pragmaid <- as.factor(final_data$pragmaid)

#check for missings
summary(final_data)
anyNA(final_data) #8 NAs in EmpType -> set to "other"
final_data$emp.type[is.na(final_data$emp.type)] <- "other"

##outliers?
## remove #all outliers that match the definition: bigger than 75% quantile + 3*IQR (Tukey's fences)

# inpat_id
boxplot(final_data$inpat_id) # some patients did 30 treatments -> remove them?
cutoff_inpatid <- quantile(final_data$inpat_id, 0.75) + 3*IQR(final_data$inpat_id)
cutoff_inpatid
#remove them
final_data <- final_data %>% filter(inpat_id <= cutoff_inpatid)

# ndays
boxplot(final_data$n.days)# many outliers
cutoff <- quantile(final_data$n.days, 0.75) + 3*IQR(final_data$n.days)
final_data <- final_data %>% filter(n.days <= cutoff)

# char_sum
boxplot(final_data$char_sum) # some outliers
cutoff_char <- quantile(final_data$char_sum, 0.75) + 3*IQR(final_data$char_sum)
cutoff_char
final_data <- final_data %>% filter(char_sum <= cutoff_char)

#elix_sum
boxplot(final_data$elix_sum) # some outliers
cuttoff_elix <- quantile(final_data$elix_sum, 0.75) + 3*IQR(final_data$elix_sum)
cuttoff_elix
final_data <- final_data %>% filter(elix_sum <= cuttoff_elix)

#ndistinctATClevel2
boxplot(final_data$ndistinctATClevel2) # some outliers
cutoff_ndistinctATClevel2 <- quantile(final_data$ndistinctATClevel2, 0.75) + 3*IQR(final_data$ndistinctATClevel2)
cutoff_ndistinctATClevel2
final_data <- final_data %>% filter(ndistinctATClevel2 <= cutoff_ndistinctATClevel2)



# check for multicollinearity
#Just run “linear regression” after assuming categorical dependent variable as continuous variable
final_data$treat_dur_cat_num <- as.numeric(final_data$treat_dur_cat)
vif_model <- lm(treat_dur_cat_num ~ sex + age + inpat_id + nationality + emp.type + elix_sum + fost.degree_bin + ndistinctATClevel2, data = final_data)

car::vif(vif_model) #no multicollinearity
#"A consequence is that when using adjusted adjusted generalized standard error inflation factor (GSIF = GVIF^(1/(2*Df)), we must take the square-root of our rules of thumb for what is a large value – aGSIF values above √2.5 (1.6) may be of concern, and values above √5 or √10 (2.2 or 3.2) are indicative of a more serious problem"




```

#Multinomiale Modelle
```{r multinom_models}
# Initialisiere einen leeren DataFrame für die Modellanpassungsparameter
model_summaries <- data.frame(
  Model = character(),
  Deviance = numeric(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

add_model_summary <- function(model, model_name) {
  summary <- getSummary.mblogit(model)
  stats <- summary$sumstat
  model_summaries <<- rbind(model_summaries, data.frame(
    Model = model_name,
    Deviance = stats["deviance"],
    AIC = stats["AIC"],
    BIC = stats["BIC"]
  ))
}

#nur Intercept und random effects
model1 <- mblogit(formula = treat_dur_cat ~ 1, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model1)
add_model_summary(model1, "Intercept")

model2 <- mblogit(formula = treat_dur_cat ~ sex, random = ~ 1 | pragmaid, data = final_data) #model 2 führt zu keiner Verbesserungen (lediglich etwas geringere deviance)
getSummary.mblogit(model2)
add_model_summary(model2, "Model 2")


model3 <- mblogit(formula = treat_dur_cat ~ sex + age, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model3) #Modell 3 hat die besten Anpassungswerte basierend auf Devianz, AIC und BIC. "age" scheint ein signifikanter Prädiktor für die Kategorien „7–20 Tage“ und „21+ Tage“ im Vergleich zu „1-6 Tage“ zu sein.
add_model_summary(model3, "Model 3")

model4 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model4) # Modell 4 bietet keinen Vorteil gegenüber Modell 3
add_model_summary(model4, "Model 4")

model5 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + nationality, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model5) # Modell 5 bietet keinen Vorteil gegenüber Modell 3 (außer leicht niedrigerer deviance), nationality wird nicht in das modell aufgenommen
add_model_summary(model5, "Model 5")


model6 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model6) # Model 6 hat besseres AIC und deviance als Modell 3, aber schlechteres BIC
add_model_summary(model6, "Model 6")

model7 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + gkv, random = ~ 1 | pragmaid, data = final_data) # Model 7 bietet keinen Vorteil gegenüber Modell 6
getSummary.mblogit(model7)
add_model_summary(model7, "Model 7")


model8 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + elix_sum, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model8) 
add_model_summary(model8, "Model 8") # elix_sum als wichtiger Prädiktor

# ist char_sum ein besserer Prädiktor?
model9 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + char_sum, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model9)
add_model_summary(model9, "Model 9") # char_sum passt schlechter als elix_sum, ist aber auch signifikant

model10 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + elix_sum + fost.degree_bin, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model10)
add_model_summary(model10, "Model 10") # keine Verbesserung gegenüber Modell 8

model11 <- mblogit(formula = treat_dur_cat ~ sex + age + inpat_id + emp.type + elix_sum + ndistinctATClevel2, random = ~ 1 | pragmaid, data = final_data)
getSummary.mblogit(model11)
add_model_summary(model11, "Model 11") 

#find the best fitting model
choose_best_model <- function(summary_df, criterion) {
  if (!criterion %in% names(summary_df)) {
    stop("Ungültiges Kriterium. Wähle entweder 'Deviance', 'AIC' oder 'BIC'.")
  }
  best_model_row <- summary_df[which.min(summary_df[[criterion]]), ]
  return(best_model_row)
}

choose_best_model(model_summaries, "BIC") #Model 3 hat den besten fit
choose_best_model(model_summaries, "AIC") #Model 8 hat den besten fit
choose_best_model(model_summaries, "Deviance") #Model 11 hat den besten fit

```
# Predicted Probabilities 

```{r plot_pred_probs}
# Predicted probabilities
# Erstelle ein neues Datenset, durch das die Variablen, die dich interessieren, variiert werden


#define function to generate new data that varies the variables of interest (age, inpat_id, elix_sum) and then plot the predicted probabilities with the variable of interest on x axis

predict_and_plot <- function(variable_of_interest, model, data) {
  # Werte für jede Variable von Interesse
  age_values <- seq(from = min(data$age,na.rm=TRUE),to=max(data$age, na.rm = TRUE), length.out = 10)  # 10 Werte für Alter
  inpat_id_values <- seq(from = min(data$inpat_id,na.rm=TRUE),to=max(data$inpat_id, na.rm = TRUE), length.out = 9)  # 4 Werte für inpat_id
  elix_sum_values <- seq(from = min(data$elix_sum,na.rm=TRUE),to=max(data$elix_sum, na.rm = TRUE), length.out = 5)  # 4 Werte für elix_sum  # Neue Daten je nach Variable von Interesse erstellen
  if (variable_of_interest == "age") {
    new_data <- expand.grid(
      age = age_values,
      sex = unique(data$sex),
      emp.type=unique(data$emp.type),
      inpat_id = mean(data$inpat_id, na.rm=TRUE),
      elix_sum=mean(data$elix_sum, na.rm = TRUE)
    )
    x_label <- "Alter"
  } else if (variable_of_interest == "inpat_id") {
    new_data <- expand.grid(
      age = mean(data$age, na.rm=TRUE),
      sex = unique(data$sex),
      emp.type=unique(data$emp.type),
      inpat_id = inpat_id_values,
      elix_sum=mean(data$elix_sum, na.rm = TRUE)
    )
    x_label <- "inpat ID"
  } else if (variable_of_interest == "elix_sum") {
    new_data <- expand.grid(
      age = mean(data$age, na.rm=TRUE),
      sex = unique(data$sex),
      emp.type=unique(data$emp.type),
      inpat_id = mean(data$inpat_id, na.rm=TRUE),
      elix_sum= elix_sum_values
    )
    x_label <- "Elixhauser Sumscore"
  } else {
    stop("Ununterstützte Variable der Interesse.")
  }
  
  # Dummy-Level für pragmaid hinzufügen, falls notwendig
  if ("pragmaid" %in% colnames(data)) {
    new_data$pragmaid <- levels(data$pragmaid)[1] # Nutze ein existierendes Level als Dummy
  }
  
  # Vorhersagen berechnen
  predicted_probs <- predict(model, newdata = new_data, type = "response")
  
  # Kombiniere die Vorhersagen mit den Eingabewerten
  predicted_data <- cbind(new_data, predicted_probs)
  
  # Reshape die Daten für ggplot
  predicted_long <- pivot_longer(predicted_data, 
                                 cols = c("1-6 Tage", "7-20 Tage", "21+ Tage"), 
                                 names_to = "treat_dur_cat", 
                                 values_to = "predicted_prob")
  
  #change the order of the levels of treat_dur_cat
  predicted_long$treat_dur_cat <- factor(predicted_long$treat_dur_cat, levels = c("1-6 Tage", "7-20 Tage", "21+ Tage"))
  
  # Plotten der vorhergesagten Wahrscheinlichkeiten
  ggplot(predicted_long, aes(x = .data[[variable_of_interest]], y = predicted_prob, color = sex)) +
    geom_line() +
    facet_grid(treat_dur_cat ~ emp.type, scales = "free") +
    xlab(x_label) +
    ylab("Vorhergesagte Wahrscheinlichkeit") +
    theme_minimal() +
    labs(color = "Geschlecht") +
    theme(legend.position = "bottom")
}


predict_and_plot("inpat_id", model8, final_data)
predict_and_plot("age", model8, final_data)
predict_and_plot("elix_sum", model8, final_data)

#save plots in folder_plot
ggsave(file.path(folder_plot, "INPAT_predicted_probs_inpatid.png"), predict_and_plot("inpat_id", model8, final_data), width = 20, height = 25, units = "cm")
ggsave(file.path(folder_plot, "INPAT_predicted_probs_age.png"), predict_and_plot("age", model8, final_data), width = 20, height = 25, units = "cm")
ggsave(file.path(folder_plot, "INPAT_predicted_probs_elix.png"), predict_and_plot("elix_sum", model8, final_data), width = 20, height = 25, units = "cm")

```
# Unterschiede zu QWT Modellen:
- Wahrscheinlichkeit für 21+ Tage steigt mit steigendem Alter (QWT Modell: sinkt, 7-20 steigt bei beiden treatments)
- Männer haben eine höhere Wahrscheinlichkeit für längere Aufenthlate (QWT Modell: Frauen), ist aber n.s. 
- Effekt von Komorbidität hat zwar die gleiche Richtung, aber ist deutlicher stärker für INPAT 21+ Tage (höhere Wahrscheinlichkeit für längere Aufenthalte)
- Effekt von IMPAT_ID ist in QWT Modell stärker, Richtung ist gleich (höhere ID, niedrigere Wahrscheinlichkeit für 21+ Tage Aufenthalte)


# Interpretation der festen Effekte (Refernzgruppe 1-6 Tage)

- kein signifikanter Effekt von Geschlecht
- signifikant positiver Koeffizienten für Alter -> mit steigendem Alter steigt die Wahrscheinlichkeit für Behandlungen von 7-20 Tagen und 21+ Tagen im Vergleich zu 1-6 Tagen
- signifikant negativer Koeffizient für inpat_ID -> mit fortlaufender QWT_ID sinkt die Wahrscheinlichkeit für Behandlungen 21+ Tagen (7-20 Tage n.s.)
- signifikant negative Koeffizient für retired (Ref. employed) -> Personen in Rente haben eine erhöhte Wahrscheinlichkeit für einen nur 1-6 tägigen Aufenthalt, sowohl vergleichen mit 7-20 Tagen als auch vergleichen mit 21+ Tagen
- signifikant negative Koeffizient für unemployed (Ref. employed) -> Unbeschäftigte haben eine erhöhte Wahrscheinlichkeit für einen nur 1-6 tägigen Aufenthalt vergleichen mit 21+ Tagen (7-20 Tage n.s.)
- signifikant positiver Koeffizient für elix_sum -> je höher der Elixhauser Score, desto höher die Wahrscheinlichkeit für einen längeren Aufenthalt (7-20 und 21+ Tage)




# Check linearity assumption
```{r check_linearity}

# ASSUMPTIONS:
#Linearity: Linear relationship between continuous variables and the logit transformation of the outcome variable. 

probabilities <- predict(model8, type = "response")
#dataset with only continuous variables
final_data_cont <- final_data %>% ungroup() %>% select_if(is.numeric) %>% select(-(c(treat_dur_cat_num, n.days, ndistinctATC, elix_sum)))

predictors <- colnames(final_data_cont)


# Logit für jede Kategorie berechnen 
logits <- apply(probabilities, 2, function(p) log(p / (1 - p)))

logits_df <- as.data.frame(logits) 
combined_data <- cbind(final_data_cont, logits_df)

final_data_long <- combined_data %>%
  pivot_longer(
    cols = all_of(names(logits_df)),  # Nutze die Spaltennamen deiner logits_df direkt
    names_to = "category",
    values_to = "logit"
  ) %>%
  pivot_longer(
    cols = all_of(predictors),   # Stelle sicher, dass predictors existiert
    names_to = "predictors",
    values_to = "predictor.value"
  )

# Scatterplot
ckeck_lin <- ggplot(final_data_long, aes(x = predictor.value, y = logit)) +
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") +
  theme_bw() +
  facet_grid(category ~ predictors, scales = "free") +
  labs(
    title = "Beziehung zwischen Prädiktoren und Logits",
    x = "Prädiktorwert",
    y = "Logit"
  ) +
    theme(
    strip.text = element_text(size = 6)  # Verkleinert die Textgröße für Facettenbeschriftungen
  )

ggsave("check_linearity.png", ckeck_lin, width = 20, height = 25, units = "cm")

#looks mostly fine, but maybe some problems with elix_sum (plot for 7-20 days), looks rather cubic than linear
```